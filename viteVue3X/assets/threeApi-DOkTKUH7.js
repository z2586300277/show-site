import{an as ln,f as L,ao as dr,a7 as on,ap as St,a8 as Pn,o as _t,aq as Ce,ar as An,as as Mt,a6 as zt,m as mr,C as we,aa as st,ad as Ln,I as oe,a1 as Xt,at as En,au as jt,av as ht,aw as rs,P as is,ax as Sn,ai as Se,ay as os,az as as,aA as ls,M as F,aB as Yt,L as ze,aC as cs,d as gr,k as Ze,F as Oe,aD as wr,aE as yr,V as Me,aF as Tr,aG as us,ag as ve,aH as Mn,aI as We,aJ as an,aK as bn,aL as vr,aM as Rn,aN as hs,ac as je,e as Ve,aO as Je,af as xr,aP as Ar,aQ as Er,l as pt,aR as Sr,aS as It,aT as ps,n as fs,aU as pn,E as ds,D as rt,aV as Mr,aW as br,p as ms,aX as gs,u as Hn,O as Rr,aY as Ir,aZ as _r,a_ as Cr,a$ as Pr,b0 as Lr,b1 as Dr,b2 as Fr,a5 as ws,aj as Or,b3 as Nr,s as dt,b4 as kr,b5 as Br,Q as Gn,t as Le,U as Ur,b as Ft,h as Hr,b6 as ys,b7 as Pe,B as Ee,b8 as Jt,a as Gr,b9 as Ot,c as zr,ba as Ts,bb as bt,bc as At,bd as Xr,be as Vr,ab as Zr,bf as jr,bg as Yr,bh as vs,al as Qr,bi as Tt,bj as Wr,r as Kr,bk as qr,bl as $r,bm as Jr,ah as ei,bn as xs,bo as ti}from"./three.module-CVsY17GA.js";import{P as As,F as ni,C as si,O as ri,E as ii,S as zn}from"./EffectComposer-CXsZCJ3S.js";/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.8.2
*/var Xe=Uint8Array,Et=Uint16Array,oi=Int32Array,Es=new Xe([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Ss=new Xe([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),ai=new Xe([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Ms=function(c,e){for(var t=new Et(31),s=0;s<31;++s)t[s]=e+=1<<c[s-1];for(var n=new oi(t[30]),s=1;s<30;++s)for(var r=t[s];r<t[s+1];++r)n[r]=r-t[s]<<5|s;return{b:t,r:n}},bs=Ms(Es,2),Rs=bs.b,li=bs.r;Rs[28]=258,li[258]=28;var ci=Ms(Ss,0),ui=ci.b,In=new Et(32768);for(var de=0;de<32768;++de){var at=(de&43690)>>1|(de&21845)<<1;at=(at&52428)>>2|(at&13107)<<2,at=(at&61680)>>4|(at&3855)<<4,In[de]=((at&65280)>>8|(at&255)<<8)>>1}var Vt=function(c,e,t){for(var s=c.length,n=0,r=new Et(e);n<s;++n)c[n]&&++r[c[n]-1];var i=new Et(e);for(n=1;n<e;++n)i[n]=i[n-1]+r[n-1]<<1;var a;if(t){a=new Et(1<<e);var l=15-e;for(n=0;n<s;++n)if(c[n])for(var h=n<<4|c[n],p=e-c[n],u=i[c[n]-1]++<<p,d=u|(1<<p)-1;u<=d;++u)a[In[u]>>l]=h}else for(a=new Et(s),n=0;n<s;++n)c[n]&&(a[n]=In[i[c[n]-1]++]>>15-c[n]);return a},Qt=new Xe(288);for(var de=0;de<144;++de)Qt[de]=8;for(var de=144;de<256;++de)Qt[de]=9;for(var de=256;de<280;++de)Qt[de]=7;for(var de=280;de<288;++de)Qt[de]=8;var Is=new Xe(32);for(var de=0;de<32;++de)Is[de]=5;var hi=Vt(Qt,9,1),pi=Vt(Is,5,1),fn=function(c){for(var e=c[0],t=1;t<c.length;++t)c[t]>e&&(e=c[t]);return e},Ye=function(c,e,t){var s=e/8|0;return(c[s]|c[s+1]<<8)>>(e&7)&t},dn=function(c,e){var t=e/8|0;return(c[t]|c[t+1]<<8|c[t+2]<<16)>>(e&7)},fi=function(c){return(c+7)/8|0},di=function(c,e,t){return(t==null||t>c.length)&&(t=c.length),new Xe(c.subarray(e,t))},mi=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],Qe=function(c,e,t){var s=new Error(e||mi[c]);if(s.code=c,Error.captureStackTrace&&Error.captureStackTrace(s,Qe),!t)throw s;return s},gi=function(c,e,t,s){var n=c.length,r=0;if(!n||e.f&&!e.l)return t||new Xe(0);var i=!t,a=i||e.i!=2,l=e.i;i&&(t=new Xe(n*3));var h=function(Ct){var Kt=t.length;if(Ct>Kt){var Pt=new Xe(Math.max(Kt*2,Ct));Pt.set(t),t=Pt}},p=e.f||0,u=e.p||0,d=e.b||0,g=e.l,T=e.d,x=e.m,v=e.n,R=n*8;do{if(!g){p=Ye(c,u,1);var _=Ye(c,u+1,3);if(u+=3,_)if(_==1)g=hi,T=pi,x=9,v=5;else if(_==2){var j=Ye(c,u,31)+257,W=Ye(c,u+10,15)+4,C=j+Ye(c,u+5,31)+1;u+=14;for(var z=new Xe(C),X=new Xe(19),Y=0;Y<W;++Y)X[ai[Y]]=Ye(c,u+Y*3,7);u+=W*3;for(var $=fn(X),ae=(1<<$)-1,Z=Vt(X,$,1),Y=0;Y<C;){var J=Z[Ye(c,u,ae)];u+=J&15;var I=J>>4;if(I<16)z[Y++]=I;else{var K=0,ue=0;for(I==16?(ue=3+Ye(c,u,3),u+=2,K=z[Y-1]):I==17?(ue=3+Ye(c,u,7),u+=3):I==18&&(ue=11+Ye(c,u,127),u+=7);ue--;)z[Y++]=K}}var Ie=z.subarray(0,j),ne=z.subarray(j);x=fn(Ie),v=fn(ne),g=Vt(Ie,x,1),T=Vt(ne,v,1)}else Qe(1);else{var I=fi(u)+4,O=c[I-4]|c[I-3]<<8,H=I+O;if(H>n){l&&Qe(0);break}a&&h(d+O),t.set(c.subarray(I,H),d),e.b=d+=O,e.p=u=H*8,e.f=p;continue}if(u>R){l&&Qe(0);break}}a&&h(d+131072);for(var pe=(1<<x)-1,Ne=(1<<v)-1,le=u;;le=u){var K=g[dn(c,u)&pe],ye=K>>4;if(u+=K&15,u>R){l&&Qe(0);break}if(K||Qe(2),ye<256)t[d++]=ye;else if(ye==256){le=u,g=null;break}else{var ke=ye-254;if(ye>264){var Y=ye-257,it=Es[Y];ke=Ye(c,u,(1<<it)-1)+Rs[Y],u+=it}var re=T[dn(c,u)&Ne],Ke=re>>4;re||Qe(3),u+=re&15;var ne=ui[Ke];if(Ke>3){var it=Ss[Ke];ne+=dn(c,u)&(1<<it)-1,u+=it}if(u>R){l&&Qe(0);break}a&&h(d+131072);var et=d+ke;if(d<ne){var Wt=r-ne,cn=Math.min(ne,et);for(Wt+d<0&&Qe(3);d<cn;++d)t[d]=s[Wt+d]}for(;d<et;++d)t[d]=t[d-ne]}}e.l=g,e.p=le,e.b=d,e.f=p,g&&(p=1,e.m=x,e.d=T,e.n=v)}while(!p);return d!=t.length&&i?di(t,0,d):t.subarray(0,d)},wi=new Xe(0),yi=function(c,e){return((c[0]&15)!=8||c[0]>>4>7||(c[0]<<8|c[1])%31)&&Qe(6,"invalid zlib data"),(c[1]>>5&1)==+!e&&Qe(6,"invalid zlib data: "+(c[1]&32?"need":"unexpected")+" dictionary"),(c[1]>>3&4)+2};function Ut(c,e){return gi(c.subarray(yi(c,e),-4),{i:2},e,e)}var Ti=typeof TextDecoder<"u"&&new TextDecoder,vi=0;try{Ti.decode(wi,{stream:!0}),vi=1}catch{}function _s(c,e,t){const s=t.length-c-1;if(e>=t[s])return s-1;if(e<=t[c])return c;let n=c,r=s,i=Math.floor((n+r)/2);for(;e<t[i]||e>=t[i+1];)e<t[i]?r=i:n=i,i=Math.floor((n+r)/2);return i}function xi(c,e,t,s){const n=[],r=[],i=[];n[0]=1;for(let a=1;a<=t;++a){r[a]=e-s[c+1-a],i[a]=s[c+a]-e;let l=0;for(let h=0;h<a;++h){const p=i[h+1],u=r[a-h],d=n[h]/(p+u);n[h]=l+p*d,l=u*d}n[a]=l}return n}function Ai(c,e,t,s){const n=_s(c,s,e),r=xi(n,s,c,e),i=new ln(0,0,0,0);for(let a=0;a<=c;++a){const l=t[n-c+a],h=r[a],p=l.w*h;i.x+=l.x*p,i.y+=l.y*p,i.z+=l.z*p,i.w+=l.w*h}return i}function Ei(c,e,t,s,n){const r=[];for(let u=0;u<=t;++u)r[u]=0;const i=[];for(let u=0;u<=s;++u)i[u]=r.slice(0);const a=[];for(let u=0;u<=t;++u)a[u]=r.slice(0);a[0][0]=1;const l=r.slice(0),h=r.slice(0);for(let u=1;u<=t;++u){l[u]=e-n[c+1-u],h[u]=n[c+u]-e;let d=0;for(let g=0;g<u;++g){const T=h[g+1],x=l[u-g];a[u][g]=T+x;const v=a[g][u-1]/a[u][g];a[g][u]=d+T*v,d=x*v}a[u][u]=d}for(let u=0;u<=t;++u)i[0][u]=a[u][t];for(let u=0;u<=t;++u){let d=0,g=1;const T=[];for(let x=0;x<=t;++x)T[x]=r.slice(0);T[0][0]=1;for(let x=1;x<=s;++x){let v=0;const R=u-x,_=t-x;u>=x&&(T[g][0]=T[d][0]/a[_+1][R],v=T[g][0]*a[R][_]);const I=R>=-1?1:-R,O=u-1<=_?x-1:t-u;for(let j=I;j<=O;++j)T[g][j]=(T[d][j]-T[d][j-1])/a[_+1][R+j],v+=T[g][j]*a[R+j][_];u<=_&&(T[g][x]=-T[d][x-1]/a[_+1][u],v+=T[g][x]*a[u][_]),i[x][u]=v;const H=d;d=g,g=H}}let p=t;for(let u=1;u<=s;++u){for(let d=0;d<=t;++d)i[u][d]*=p;p*=t-u}return i}function Si(c,e,t,s,n){const r=n<c?n:c,i=[],a=_s(c,s,e),l=Ei(a,s,c,r,e),h=[];for(let p=0;p<t.length;++p){const u=t[p].clone(),d=u.w;u.x*=d,u.y*=d,u.z*=d,h[p]=u}for(let p=0;p<=r;++p){const u=h[a-c].clone().multiplyScalar(l[p][0]);for(let d=1;d<=c;++d)u.add(h[a-c+d].clone().multiplyScalar(l[p][d]));i[p]=u}for(let p=r+1;p<=n+1;++p)i[p]=new ln(0,0,0);return i}function Mi(c,e){let t=1;for(let n=2;n<=c;++n)t*=n;let s=1;for(let n=2;n<=e;++n)s*=n;for(let n=2;n<=c-e;++n)s*=n;return t/s}function bi(c){const e=c.length,t=[],s=[];for(let r=0;r<e;++r){const i=c[r];t[r]=new L(i.x,i.y,i.z),s[r]=i.w}const n=[];for(let r=0;r<e;++r){const i=t[r].clone();for(let a=1;a<=r;++a)i.sub(n[r-a].clone().multiplyScalar(Mi(r,a)*s[a]));n[r]=i.divideScalar(s[0])}return n}function Ri(c,e,t,s,n){const r=Si(c,e,t,s,n);return bi(r)}class Ii extends dr{constructor(e,t,s,n,r){super(),this.degree=e,this.knots=t,this.controlPoints=[],this.startKnot=n||0,this.endKnot=r||this.knots.length-1;for(let i=0;i<s.length;++i){const a=s[i];this.controlPoints[i]=new ln(a.x,a.y,a.z,a.w)}}getPoint(e,t=new L){const s=t,n=this.knots[this.startKnot]+e*(this.knots[this.endKnot]-this.knots[this.startKnot]),r=Ai(this.degree,this.knots,this.controlPoints,n);return r.w!==1&&r.divideScalar(r.w),s.set(r.x,r.y,r.z)}getTangent(e,t=new L){const s=t,n=this.knots[0]+e*(this.knots[this.knots.length-1]-this.knots[0]),r=Ri(this.degree,this.knots,this.controlPoints,n,1);return s.copy(r[1]).normalize(),s}}let q,Te,_e;class _i extends on{constructor(e){super(e)}load(e,t,s,n){const r=this,i=r.path===""?St.extractUrlBase(e):r.path,a=new Pn(this.manager);a.setPath(r.path),a.setResponseType("arraybuffer"),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(e,function(l){try{t(r.parse(l,i))}catch(h){n?n(h):console.error(h),r.manager.itemError(e)}},s,n)}parse(e,t){if(Oi(e))q=new Fi().parse(e);else{const n=Ds(e);if(!Ni(n))throw new Error("THREE.FBXLoader: Unknown format.");if(Vn(n)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+Vn(n));q=new Di().parse(n)}const s=new _t(this.manager).setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin);return new Ci(s,this.manager).parse(q)}}class Ci{constructor(e,t){this.textureLoader=e,this.manager=t}parse(){Te=this.parseConnections();const e=this.parseImages(),t=this.parseTextures(e),s=this.parseMaterials(t),n=this.parseDeformers(),r=new Pi().parse(n);return this.parseScene(n,r,s),_e}parseConnections(){const e=new Map;return"Connections"in q&&q.Connections.connections.forEach(function(s){const n=s[0],r=s[1],i=s[2];e.has(n)||e.set(n,{parents:[],children:[]});const a={ID:r,relationship:i};e.get(n).parents.push(a),e.has(r)||e.set(r,{parents:[],children:[]});const l={ID:n,relationship:i};e.get(r).children.push(l)}),e}parseImages(){const e={},t={};if("Video"in q.Objects){const s=q.Objects.Video;for(const n in s){const r=s[n],i=parseInt(n);if(e[i]=r.RelativeFilename||r.Filename,"Content"in r){const a=r.Content instanceof ArrayBuffer&&r.Content.byteLength>0,l=typeof r.Content=="string"&&r.Content!=="";if(a||l){const h=this.parseImage(s[n]);t[r.RelativeFilename||r.Filename]=h}}}}for(const s in e){const n=e[s];t[n]!==void 0?e[s]=t[n]:e[s]=e[s].split("\\").pop()}return e}parseImage(e){const t=e.Content,s=e.RelativeFilename||e.Filename,n=s.slice(s.lastIndexOf(".")+1).toLowerCase();let r;switch(n){case"bmp":r="image/bmp";break;case"jpg":case"jpeg":r="image/jpeg";break;case"png":r="image/png";break;case"tif":r="image/tiff";break;case"tga":this.manager.getHandler(".tga")===null&&console.warn("FBXLoader: TGA loader not found, skipping ",s),r="image/tga";break;default:console.warn('FBXLoader: Image type "'+n+'" is not supported.');return}if(typeof t=="string")return"data:"+r+";base64,"+t;{const i=new Uint8Array(t);return window.URL.createObjectURL(new Blob([i],{type:r}))}}parseTextures(e){const t=new Map;if("Texture"in q.Objects){const s=q.Objects.Texture;for(const n in s){const r=this.parseTexture(s[n],e);t.set(parseInt(n),r)}}return t}parseTexture(e,t){const s=this.loadTexture(e,t);s.ID=e.id,s.name=e.attrName;const n=e.WrapModeU,r=e.WrapModeV,i=n!==void 0?n.value:0,a=r!==void 0?r.value:0;if(s.wrapS=i===0?Ce:An,s.wrapT=a===0?Ce:An,"Scaling"in e){const l=e.Scaling.value;s.repeat.x=l[0],s.repeat.y=l[1]}if("Translation"in e){const l=e.Translation.value;s.offset.x=l[0],s.offset.y=l[1]}return s}loadTexture(e,t){let s;const n=this.textureLoader.path,r=Te.get(e.id).children;r!==void 0&&r.length>0&&t[r[0].ID]!==void 0&&(s=t[r[0].ID],(s.indexOf("blob:")===0||s.indexOf("data:")===0)&&this.textureLoader.setPath(void 0));let i;const a=e.FileName.slice(-3).toLowerCase();if(a==="tga"){const l=this.manager.getHandler(".tga");l===null?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",e.RelativeFilename),i=new Mt):(l.setPath(this.textureLoader.path),i=l.load(s))}else if(a==="dds"){const l=this.manager.getHandler(".dds");l===null?(console.warn("FBXLoader: DDS loader not found, creating placeholder texture for",e.RelativeFilename),i=new Mt):(l.setPath(this.textureLoader.path),i=l.load(s))}else a==="psd"?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",e.RelativeFilename),i=new Mt):i=this.textureLoader.load(s);return this.textureLoader.setPath(n),i}parseMaterials(e){const t=new Map;if("Material"in q.Objects){const s=q.Objects.Material;for(const n in s){const r=this.parseMaterial(s[n],e);r!==null&&t.set(parseInt(n),r)}}return t}parseMaterial(e,t){const s=e.id,n=e.attrName;let r=e.ShadingModel;if(typeof r=="object"&&(r=r.value),!Te.has(s))return null;const i=this.parseParameters(e,t,s);let a;switch(r.toLowerCase()){case"phong":a=new zt;break;case"lambert":a=new mr;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',r),a=new zt;break}return a.setValues(i),a.name=n,a}parseParameters(e,t,s){const n={};e.BumpFactor&&(n.bumpScale=e.BumpFactor.value),e.Diffuse?n.color=new we().fromArray(e.Diffuse.value).convertSRGBToLinear():e.DiffuseColor&&(e.DiffuseColor.type==="Color"||e.DiffuseColor.type==="ColorRGB")&&(n.color=new we().fromArray(e.DiffuseColor.value).convertSRGBToLinear()),e.DisplacementFactor&&(n.displacementScale=e.DisplacementFactor.value),e.Emissive?n.emissive=new we().fromArray(e.Emissive.value).convertSRGBToLinear():e.EmissiveColor&&(e.EmissiveColor.type==="Color"||e.EmissiveColor.type==="ColorRGB")&&(n.emissive=new we().fromArray(e.EmissiveColor.value).convertSRGBToLinear()),e.EmissiveFactor&&(n.emissiveIntensity=parseFloat(e.EmissiveFactor.value)),e.Opacity&&(n.opacity=parseFloat(e.Opacity.value)),n.opacity<1&&(n.transparent=!0),e.ReflectionFactor&&(n.reflectivity=e.ReflectionFactor.value),e.Shininess&&(n.shininess=e.Shininess.value),e.Specular?n.specular=new we().fromArray(e.Specular.value).convertSRGBToLinear():e.SpecularColor&&e.SpecularColor.type==="Color"&&(n.specular=new we().fromArray(e.SpecularColor.value).convertSRGBToLinear());const r=this;return Te.get(s).children.forEach(function(i){const a=i.relationship;switch(a){case"Bump":n.bumpMap=r.getTexture(t,i.ID);break;case"Maya|TEX_ao_map":n.aoMap=r.getTexture(t,i.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":n.map=r.getTexture(t,i.ID),n.map!==void 0&&(n.map.colorSpace=st);break;case"DisplacementColor":n.displacementMap=r.getTexture(t,i.ID);break;case"EmissiveColor":n.emissiveMap=r.getTexture(t,i.ID),n.emissiveMap!==void 0&&(n.emissiveMap.colorSpace=st);break;case"NormalMap":case"Maya|TEX_normal_map":n.normalMap=r.getTexture(t,i.ID);break;case"ReflectionColor":n.envMap=r.getTexture(t,i.ID),n.envMap!==void 0&&(n.envMap.mapping=Ln,n.envMap.colorSpace=st);break;case"SpecularColor":n.specularMap=r.getTexture(t,i.ID),n.specularMap!==void 0&&(n.specularMap.colorSpace=st);break;case"TransparentColor":case"TransparencyFactor":n.alphaMap=r.getTexture(t,i.ID),n.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",a);break}}),n}getTexture(e,t){return"LayeredTexture"in q.Objects&&t in q.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),t=Te.get(t).children[0].ID),e.get(t)}parseDeformers(){const e={},t={};if("Deformer"in q.Objects){const s=q.Objects.Deformer;for(const n in s){const r=s[n],i=Te.get(parseInt(n));if(r.attrType==="Skin"){const a=this.parseSkeleton(i,s);a.ID=n,i.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),a.geometryID=i.parents[0].ID,e[n]=a}else if(r.attrType==="BlendShape"){const a={id:n};a.rawTargets=this.parseMorphTargets(i,s),a.id=n,i.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),t[n]=a}}}return{skeletons:e,morphTargets:t}}parseSkeleton(e,t){const s=[];return e.children.forEach(function(n){const r=t[n.ID];if(r.attrType!=="Cluster")return;const i={ID:n.ID,indices:[],weights:[],transformLink:new oe().fromArray(r.TransformLink.a)};"Indexes"in r&&(i.indices=r.Indexes.a,i.weights=r.Weights.a),s.push(i)}),{rawBones:s,bones:[]}}parseMorphTargets(e,t){const s=[];for(let n=0;n<e.children.length;n++){const r=e.children[n],i=t[r.ID],a={name:i.attrName,initialWeight:i.DeformPercent,id:i.id,fullWeights:i.FullWeights.a};if(i.attrType!=="BlendShapeChannel")return;a.geoID=Te.get(parseInt(r.ID)).children.filter(function(l){return l.relationship===void 0})[0].ID,s.push(a)}return s}parseScene(e,t,s){_e=new Xt;const n=this.parseModels(e.skeletons,t,s),r=q.Objects.Model,i=this;n.forEach(function(l){const h=r[l.ID];i.setLookAtProperties(l,h),Te.get(l.ID).parents.forEach(function(u){const d=n.get(u.ID);d!==void 0&&d.add(l)}),l.parent===null&&_e.add(l)}),this.bindSkeleton(e.skeletons,t,n),this.addGlobalSceneSettings(),_e.traverse(function(l){if(l.userData.transformData){l.parent&&(l.userData.transformData.parentMatrix=l.parent.matrix,l.userData.transformData.parentMatrixWorld=l.parent.matrixWorld);const h=Ps(l.userData.transformData);l.applyMatrix4(h),l.updateWorldMatrix()}});const a=new Li().parse();_e.children.length===1&&_e.children[0].isGroup&&(_e.children[0].animations=a,_e=_e.children[0]),_e.animations=a}parseModels(e,t,s){const n=new Map,r=q.Objects.Model;for(const i in r){const a=parseInt(i),l=r[i],h=Te.get(a);let p=this.buildSkeleton(h,e,a,l.attrName);if(!p){switch(l.attrType){case"Camera":p=this.createCamera(h);break;case"Light":p=this.createLight(h);break;case"Mesh":p=this.createMesh(h,t,s);break;case"NurbsCurve":p=this.createCurve(h,t);break;case"LimbNode":case"Root":p=new En;break;case"Null":default:p=new Xt;break}p.name=l.attrName?jt.sanitizeNodeName(l.attrName):"",p.userData.originalName=l.attrName,p.ID=a}this.getTransformData(p,l),n.set(a,p)}return n}buildSkeleton(e,t,s,n){let r=null;return e.parents.forEach(function(i){for(const a in t){const l=t[a];l.rawBones.forEach(function(h,p){if(h.ID===i.ID){const u=r;r=new En,r.matrixWorld.copy(h.transformLink),r.name=n?jt.sanitizeNodeName(n):"",r.userData.originalName=n,r.ID=s,l.bones[p]=r,u!==null&&r.add(u)}})}}),r}createCamera(e){let t,s;if(e.children.forEach(function(n){const r=q.Objects.NodeAttribute[n.ID];r!==void 0&&(s=r)}),s===void 0)t=new ht;else{let n=0;s.CameraProjectionType!==void 0&&s.CameraProjectionType.value===1&&(n=1);let r=1;s.NearPlane!==void 0&&(r=s.NearPlane.value/1e3);let i=1e3;s.FarPlane!==void 0&&(i=s.FarPlane.value/1e3);let a=window.innerWidth,l=window.innerHeight;s.AspectWidth!==void 0&&s.AspectHeight!==void 0&&(a=s.AspectWidth.value,l=s.AspectHeight.value);const h=a/l;let p=45;s.FieldOfView!==void 0&&(p=s.FieldOfView.value);const u=s.FocalLength?s.FocalLength.value:null;switch(n){case 0:t=new is(p,h,r,i),u!==null&&t.setFocalLength(u);break;case 1:t=new rs(-a/2,a/2,l/2,-l/2,r,i);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+n+"."),t=new ht;break}}return t}createLight(e){let t,s;if(e.children.forEach(function(n){const r=q.Objects.NodeAttribute[n.ID];r!==void 0&&(s=r)}),s===void 0)t=new ht;else{let n;s.LightType===void 0?n=0:n=s.LightType.value;let r=16777215;s.Color!==void 0&&(r=new we().fromArray(s.Color.value).convertSRGBToLinear());let i=s.Intensity===void 0?1:s.Intensity.value/100;s.CastLightOnObject!==void 0&&s.CastLightOnObject.value===0&&(i=0);let a=0;s.FarAttenuationEnd!==void 0&&(s.EnableFarAttenuation!==void 0&&s.EnableFarAttenuation.value===0?a=0:a=s.FarAttenuationEnd.value);const l=1;switch(n){case 0:t=new Sn(r,i,a,l);break;case 1:t=new as(r,i);break;case 2:let h=Math.PI/3;s.InnerAngle!==void 0&&(h=Se.degToRad(s.InnerAngle.value));let p=0;s.OuterAngle!==void 0&&(p=Se.degToRad(s.OuterAngle.value),p=Math.max(p,1)),t=new os(r,i,a,h,p,l);break;default:console.warn("THREE.FBXLoader: Unknown light type "+s.LightType.value+", defaulting to a PointLight."),t=new Sn(r,i);break}s.CastShadows!==void 0&&s.CastShadows.value===1&&(t.castShadow=!0)}return t}createMesh(e,t,s){let n,r=null,i=null;const a=[];return e.children.forEach(function(l){t.has(l.ID)&&(r=t.get(l.ID)),s.has(l.ID)&&a.push(s.get(l.ID))}),a.length>1?i=a:a.length>0?i=a[0]:(i=new zt({name:on.DEFAULT_MATERIAL_NAME,color:13421772}),a.push(i)),"color"in r.attributes&&a.forEach(function(l){l.vertexColors=!0}),r.FBX_Deformer?(n=new ls(r,i),n.normalizeSkinWeights()):n=new F(r,i),n}createCurve(e,t){const s=e.children.reduce(function(r,i){return t.has(i.ID)&&(r=t.get(i.ID)),r},null),n=new Yt({name:on.DEFAULT_MATERIAL_NAME,color:3342591,linewidth:1});return new ze(s,n)}getTransformData(e,t){const s={};"InheritType"in t&&(s.inheritType=parseInt(t.InheritType.value)),"RotationOrder"in t?s.eulerOrder=Ls(t.RotationOrder.value):s.eulerOrder="ZYX","Lcl_Translation"in t&&(s.translation=t.Lcl_Translation.value),"PreRotation"in t&&(s.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(s.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(s.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(s.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(s.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(s.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(s.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(s.rotationPivot=t.RotationPivot.value),e.userData.transformData=s}setLookAtProperties(e,t){"LookAtProperty"in t&&Te.get(e.ID).children.forEach(function(n){if(n.relationship==="LookAtProperty"){const r=q.Objects.Model[n.ID];if("Lcl_Translation"in r){const i=r.Lcl_Translation.value;e.target!==void 0?(e.target.position.fromArray(i),_e.add(e.target)):e.lookAt(new L().fromArray(i))}}})}bindSkeleton(e,t,s){const n=this.parsePoseNodes();for(const r in e){const i=e[r];Te.get(parseInt(i.ID)).parents.forEach(function(l){if(t.has(l.ID)){const h=l.ID;Te.get(h).parents.forEach(function(u){s.has(u.ID)&&s.get(u.ID).bind(new cs(i.bones),n[u.ID])})}})}}parsePoseNodes(){const e={};if("Pose"in q.Objects){const t=q.Objects.Pose;for(const s in t)if(t[s].attrType==="BindPose"&&t[s].NbPoseNodes>0){const n=t[s].PoseNode;Array.isArray(n)?n.forEach(function(r){e[r.Node]=new oe().fromArray(r.Matrix.a)}):e[n.Node]=new oe().fromArray(n.Matrix.a)}}return e}addGlobalSceneSettings(){if("GlobalSettings"in q){if("AmbientColor"in q.GlobalSettings){const e=q.GlobalSettings.AmbientColor.value,t=e[0],s=e[1],n=e[2];if(t!==0||s!==0||n!==0){const r=new we(t,s,n).convertSRGBToLinear();_e.add(new gr(r,1))}}"UnitScaleFactor"in q.GlobalSettings&&(_e.userData.unitScaleFactor=q.GlobalSettings.UnitScaleFactor.value)}}}class Pi{constructor(){this.negativeMaterialIndices=!1}parse(e){const t=new Map;if("Geometry"in q.Objects){const s=q.Objects.Geometry;for(const n in s){const r=Te.get(parseInt(n)),i=this.parseGeometry(r,s[n],e);t.set(parseInt(n),i)}}return this.negativeMaterialIndices===!0&&console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."),t}parseGeometry(e,t,s){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,s);case"NurbsCurve":return this.parseNurbsGeometry(t)}}parseMeshGeometry(e,t,s){const n=s.skeletons,r=[],i=e.parents.map(function(u){return q.Objects.Model[u.ID]});if(i.length===0)return;const a=e.children.reduce(function(u,d){return n[d.ID]!==void 0&&(u=n[d.ID]),u},null);e.children.forEach(function(u){s.morphTargets[u.ID]!==void 0&&r.push(s.morphTargets[u.ID])});const l=i[0],h={};"RotationOrder"in l&&(h.eulerOrder=Ls(l.RotationOrder.value)),"InheritType"in l&&(h.inheritType=parseInt(l.InheritType.value)),"GeometricTranslation"in l&&(h.translation=l.GeometricTranslation.value),"GeometricRotation"in l&&(h.rotation=l.GeometricRotation.value),"GeometricScaling"in l&&(h.scale=l.GeometricScaling.value);const p=Ps(h);return this.genGeometry(t,a,r,p)}genGeometry(e,t,s,n){const r=new Ze;e.attrName&&(r.name=e.attrName);const i=this.parseGeoNode(e,t),a=this.genBuffers(i),l=new Oe(a.vertex,3);if(l.applyMatrix4(n),r.setAttribute("position",l),a.colors.length>0&&r.setAttribute("color",new Oe(a.colors,3)),t&&(r.setAttribute("skinIndex",new wr(a.weightsIndices,4)),r.setAttribute("skinWeight",new Oe(a.vertexWeights,4)),r.FBX_Deformer=t),a.normal.length>0){const h=new yr().getNormalMatrix(n),p=new Oe(a.normal,3);p.applyNormalMatrix(h),r.setAttribute("normal",p)}if(a.uvs.forEach(function(h,p){const u=p===0?"uv":`uv${p}`;r.setAttribute(u,new Oe(a.uvs[p],2))}),i.material&&i.material.mappingType!=="AllSame"){let h=a.materialIndex[0],p=0;if(a.materialIndex.forEach(function(u,d){u!==h&&(r.addGroup(p,d-p,h),h=u,p=d)}),r.groups.length>0){const u=r.groups[r.groups.length-1],d=u.start+u.count;d!==a.materialIndex.length&&r.addGroup(d,a.materialIndex.length-d,h)}r.groups.length===0&&r.addGroup(0,a.materialIndex.length,a.materialIndex[0])}return this.addMorphTargets(r,e,s,n),r}parseGeoNode(e,t){const s={};if(s.vertexPositions=e.Vertices!==void 0?e.Vertices.a:[],s.vertexIndices=e.PolygonVertexIndex!==void 0?e.PolygonVertexIndex.a:[],e.LayerElementColor&&(s.color=this.parseVertexColors(e.LayerElementColor[0])),e.LayerElementMaterial&&(s.material=this.parseMaterialIndices(e.LayerElementMaterial[0])),e.LayerElementNormal&&(s.normal=this.parseNormals(e.LayerElementNormal[0])),e.LayerElementUV){s.uv=[];let n=0;for(;e.LayerElementUV[n];)e.LayerElementUV[n].UV&&s.uv.push(this.parseUVs(e.LayerElementUV[n])),n++}return s.weightTable={},t!==null&&(s.skeleton=t,t.rawBones.forEach(function(n,r){n.indices.forEach(function(i,a){s.weightTable[i]===void 0&&(s.weightTable[i]=[]),s.weightTable[i].push({id:r,weight:n.weights[a]})})})),s}genBuffers(e){const t={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let s=0,n=0,r=!1,i=[],a=[],l=[],h=[],p=[],u=[];const d=this;return e.vertexIndices.forEach(function(g,T){let x,v=!1;g<0&&(g=g^-1,v=!0);let R=[],_=[];if(i.push(g*3,g*3+1,g*3+2),e.color){const I=en(T,s,g,e.color);l.push(I[0],I[1],I[2])}if(e.skeleton){if(e.weightTable[g]!==void 0&&e.weightTable[g].forEach(function(I){_.push(I.weight),R.push(I.id)}),_.length>4){r||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),r=!0);const I=[0,0,0,0],O=[0,0,0,0];_.forEach(function(H,j){let W=H,C=R[j];O.forEach(function(z,X,Y){if(W>z){Y[X]=W,W=z;const $=I[X];I[X]=C,C=$}})}),R=I,_=O}for(;_.length<4;)_.push(0),R.push(0);for(let I=0;I<4;++I)p.push(_[I]),u.push(R[I])}if(e.normal){const I=en(T,s,g,e.normal);a.push(I[0],I[1],I[2])}e.material&&e.material.mappingType!=="AllSame"&&(x=en(T,s,g,e.material)[0],x<0&&(d.negativeMaterialIndices=!0,x=0)),e.uv&&e.uv.forEach(function(I,O){const H=en(T,s,g,I);h[O]===void 0&&(h[O]=[]),h[O].push(H[0]),h[O].push(H[1])}),n++,v&&(d.genFace(t,e,i,x,a,l,h,p,u,n),s++,n=0,i=[],a=[],l=[],h=[],p=[],u=[])}),t}getNormalNewell(e){const t=new L(0,0,0);for(let s=0;s<e.length;s++){const n=e[s],r=e[(s+1)%e.length];t.x+=(n.y-r.y)*(n.z+r.z),t.y+=(n.z-r.z)*(n.x+r.x),t.z+=(n.x-r.x)*(n.y+r.y)}return t.normalize(),t}getNormalTangentAndBitangent(e){const t=this.getNormalNewell(e),n=(Math.abs(t.z)>.5?new L(0,1,0):new L(0,0,1)).cross(t).normalize(),r=t.clone().cross(n).normalize();return{normal:t,tangent:n,bitangent:r}}flattenVertex(e,t,s){return new Me(e.dot(t),e.dot(s))}genFace(e,t,s,n,r,i,a,l,h,p){let u;if(p>3){const d=[],g=t.baseVertexPositions||t.vertexPositions;for(let R=0;R<s.length;R+=3)d.push(new L(g[s[R]],g[s[R+1]],g[s[R+2]]));const{tangent:T,bitangent:x}=this.getNormalTangentAndBitangent(d),v=[];for(const R of d)v.push(this.flattenVertex(R,T,x));u=Tr.triangulateShape(v,[])}else u=[[0,1,2]];for(const[d,g,T]of u)e.vertex.push(t.vertexPositions[s[d*3]]),e.vertex.push(t.vertexPositions[s[d*3+1]]),e.vertex.push(t.vertexPositions[s[d*3+2]]),e.vertex.push(t.vertexPositions[s[g*3]]),e.vertex.push(t.vertexPositions[s[g*3+1]]),e.vertex.push(t.vertexPositions[s[g*3+2]]),e.vertex.push(t.vertexPositions[s[T*3]]),e.vertex.push(t.vertexPositions[s[T*3+1]]),e.vertex.push(t.vertexPositions[s[T*3+2]]),t.skeleton&&(e.vertexWeights.push(l[d*4]),e.vertexWeights.push(l[d*4+1]),e.vertexWeights.push(l[d*4+2]),e.vertexWeights.push(l[d*4+3]),e.vertexWeights.push(l[g*4]),e.vertexWeights.push(l[g*4+1]),e.vertexWeights.push(l[g*4+2]),e.vertexWeights.push(l[g*4+3]),e.vertexWeights.push(l[T*4]),e.vertexWeights.push(l[T*4+1]),e.vertexWeights.push(l[T*4+2]),e.vertexWeights.push(l[T*4+3]),e.weightsIndices.push(h[d*4]),e.weightsIndices.push(h[d*4+1]),e.weightsIndices.push(h[d*4+2]),e.weightsIndices.push(h[d*4+3]),e.weightsIndices.push(h[g*4]),e.weightsIndices.push(h[g*4+1]),e.weightsIndices.push(h[g*4+2]),e.weightsIndices.push(h[g*4+3]),e.weightsIndices.push(h[T*4]),e.weightsIndices.push(h[T*4+1]),e.weightsIndices.push(h[T*4+2]),e.weightsIndices.push(h[T*4+3])),t.color&&(e.colors.push(i[d*3]),e.colors.push(i[d*3+1]),e.colors.push(i[d*3+2]),e.colors.push(i[g*3]),e.colors.push(i[g*3+1]),e.colors.push(i[g*3+2]),e.colors.push(i[T*3]),e.colors.push(i[T*3+1]),e.colors.push(i[T*3+2])),t.material&&t.material.mappingType!=="AllSame"&&(e.materialIndex.push(n),e.materialIndex.push(n),e.materialIndex.push(n)),t.normal&&(e.normal.push(r[d*3]),e.normal.push(r[d*3+1]),e.normal.push(r[d*3+2]),e.normal.push(r[g*3]),e.normal.push(r[g*3+1]),e.normal.push(r[g*3+2]),e.normal.push(r[T*3]),e.normal.push(r[T*3+1]),e.normal.push(r[T*3+2])),t.uv&&t.uv.forEach(function(x,v){e.uvs[v]===void 0&&(e.uvs[v]=[]),e.uvs[v].push(a[v][d*2]),e.uvs[v].push(a[v][d*2+1]),e.uvs[v].push(a[v][g*2]),e.uvs[v].push(a[v][g*2+1]),e.uvs[v].push(a[v][T*2]),e.uvs[v].push(a[v][T*2+1])})}addMorphTargets(e,t,s,n){if(s.length===0)return;e.morphTargetsRelative=!0,e.morphAttributes.position=[];const r=this;s.forEach(function(i){i.rawTargets.forEach(function(a){const l=q.Objects.Geometry[a.geoID];l!==void 0&&r.genMorphGeometry(e,t,l,n,a.name)})})}genMorphGeometry(e,t,s,n,r){const i=t.Vertices!==void 0?t.Vertices.a:[],a=t.PolygonVertexIndex!==void 0?t.PolygonVertexIndex.a:[],l=s.Vertices!==void 0?s.Vertices.a:[],h=s.Indexes!==void 0?s.Indexes.a:[],p=e.attributes.position.count*3,u=new Float32Array(p);for(let x=0;x<h.length;x++){const v=h[x]*3;u[v]=l[x*3],u[v+1]=l[x*3+1],u[v+2]=l[x*3+2]}const d={vertexIndices:a,vertexPositions:u,baseVertexPositions:i},g=this.genBuffers(d),T=new Oe(g.vertex,3);T.name=r||s.attrName,T.applyMatrix4(n),e.morphAttributes.position.push(T)}parseNormals(e){const t=e.MappingInformationType,s=e.ReferenceInformationType,n=e.Normals.a;let r=[];return s==="IndexToDirect"&&("NormalIndex"in e?r=e.NormalIndex.a:"NormalsIndex"in e&&(r=e.NormalsIndex.a)),{dataSize:3,buffer:n,indices:r,mappingType:t,referenceType:s}}parseUVs(e){const t=e.MappingInformationType,s=e.ReferenceInformationType,n=e.UV.a;let r=[];return s==="IndexToDirect"&&(r=e.UVIndex.a),{dataSize:2,buffer:n,indices:r,mappingType:t,referenceType:s}}parseVertexColors(e){const t=e.MappingInformationType,s=e.ReferenceInformationType,n=e.Colors.a;let r=[];s==="IndexToDirect"&&(r=e.ColorIndex.a);for(let i=0,a=new we;i<n.length;i+=4)a.fromArray(n,i).convertSRGBToLinear().toArray(n,i);return{dataSize:4,buffer:n,indices:r,mappingType:t,referenceType:s}}parseMaterialIndices(e){const t=e.MappingInformationType,s=e.ReferenceInformationType;if(t==="NoMappingInformation")return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:s};const n=e.Materials.a,r=[];for(let i=0;i<n.length;++i)r.push(i);return{dataSize:1,buffer:n,indices:r,mappingType:t,referenceType:s}}parseNurbsGeometry(e){const t=parseInt(e.Order);if(isNaN(t))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",e.Order,e.id),new Ze;const s=t-1,n=e.KnotVector.a,r=[],i=e.Points.a;for(let u=0,d=i.length;u<d;u+=4)r.push(new ln().fromArray(i,u));let a,l;if(e.Form==="Closed")r.push(r[0]);else if(e.Form==="Periodic"){a=s,l=n.length-1-a;for(let u=0;u<s;++u)r.push(r[u])}const p=new Ii(s,n,r,a,l).getPoints(r.length*12);return new Ze().setFromPoints(p)}}class Li{parse(){const e=[],t=this.parseClips();if(t!==void 0)for(const s in t){const n=t[s],r=this.addClip(n);e.push(r)}return e}parseClips(){if(q.Objects.AnimationCurve===void 0)return;const e=this.parseAnimationCurveNodes();this.parseAnimationCurves(e);const t=this.parseAnimationLayers(e);return this.parseAnimStacks(t)}parseAnimationCurveNodes(){const e=q.Objects.AnimationCurveNode,t=new Map;for(const s in e){const n=e[s];if(n.attrName.match(/S|R|T|DeformPercent/)!==null){const r={id:n.id,attr:n.attrName,curves:{}};t.set(r.id,r)}}return t}parseAnimationCurves(e){const t=q.Objects.AnimationCurve;for(const s in t){const n={id:t[s].id,times:t[s].KeyTime.a.map(ki),values:t[s].KeyValueFloat.a},r=Te.get(n.id);if(r!==void 0){const i=r.parents[0].ID,a=r.parents[0].relationship;a.match(/X/)?e.get(i).curves.x=n:a.match(/Y/)?e.get(i).curves.y=n:a.match(/Z/)?e.get(i).curves.z=n:a.match(/DeformPercent/)&&e.has(i)&&(e.get(i).curves.morph=n)}}}parseAnimationLayers(e){const t=q.Objects.AnimationLayer,s=new Map;for(const n in t){const r=[],i=Te.get(parseInt(n));i!==void 0&&(i.children.forEach(function(l,h){if(e.has(l.ID)){const p=e.get(l.ID);if(p.curves.x!==void 0||p.curves.y!==void 0||p.curves.z!==void 0){if(r[h]===void 0){const u=Te.get(l.ID).parents.filter(function(d){return d.relationship!==void 0})[0].ID;if(u!==void 0){const d=q.Objects.Model[u.toString()];if(d===void 0){console.warn("THREE.FBXLoader: Encountered a unused curve.",l);return}const g={modelName:d.attrName?jt.sanitizeNodeName(d.attrName):"",ID:d.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};_e.traverse(function(T){T.ID===d.id&&(g.transform=T.matrix,T.userData.transformData&&(g.eulerOrder=T.userData.transformData.eulerOrder))}),g.transform||(g.transform=new oe),"PreRotation"in d&&(g.preRotation=d.PreRotation.value),"PostRotation"in d&&(g.postRotation=d.PostRotation.value),r[h]=g}}r[h]&&(r[h][p.attr]=p)}else if(p.curves.morph!==void 0){if(r[h]===void 0){const u=Te.get(l.ID).parents.filter(function(R){return R.relationship!==void 0})[0].ID,d=Te.get(u).parents[0].ID,g=Te.get(d).parents[0].ID,T=Te.get(g).parents[0].ID,x=q.Objects.Model[T],v={modelName:x.attrName?jt.sanitizeNodeName(x.attrName):"",morphName:q.Objects.Deformer[u].attrName};r[h]=v}r[h][p.attr]=p}}}),s.set(parseInt(n),r))}return s}parseAnimStacks(e){const t=q.Objects.AnimationStack,s={};for(const n in t){const r=Te.get(parseInt(n)).children;r.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const i=e.get(r[0].ID);s[n]={name:t[n].attrName,layer:i}}return s}addClip(e){let t=[];const s=this;return e.layer.forEach(function(n){t=t.concat(s.generateTracks(n))}),new us(e.name,-1,t)}generateTracks(e){const t=[];let s=new L,n=new L;if(e.transform&&e.transform.decompose(s,new ve,n),s=s.toArray(),n=n.toArray(),e.T!==void 0&&Object.keys(e.T.curves).length>0){const r=this.generateVectorTrack(e.modelName,e.T.curves,s,"position");r!==void 0&&t.push(r)}if(e.R!==void 0&&Object.keys(e.R.curves).length>0){const r=this.generateRotationTrack(e.modelName,e.R.curves,e.preRotation,e.postRotation,e.eulerOrder);r!==void 0&&t.push(r)}if(e.S!==void 0&&Object.keys(e.S.curves).length>0){const r=this.generateVectorTrack(e.modelName,e.S.curves,n,"scale");r!==void 0&&t.push(r)}if(e.DeformPercent!==void 0){const r=this.generateMorphTrack(e);r!==void 0&&t.push(r)}return t}generateVectorTrack(e,t,s,n){const r=this.getTimesForAllAxes(t),i=this.getKeyframeTrackValues(r,t,s);return new Mn(e+"."+n,r,i)}generateRotationTrack(e,t,s,n,r){let i,a;if(t.x!==void 0&&t.y!==void 0&&t.z!==void 0){const u=this.interpolateRotations(t.x,t.y,t.z,r);i=u[0],a=u[1]}s!==void 0&&(s=s.map(Se.degToRad),s.push(r),s=new We().fromArray(s),s=new ve().setFromEuler(s)),n!==void 0&&(n=n.map(Se.degToRad),n.push(r),n=new We().fromArray(n),n=new ve().setFromEuler(n).invert());const l=new ve,h=new We,p=[];if(!a||!i)return new an(e+".quaternion",[0],[0]);for(let u=0;u<a.length;u+=3)h.set(a[u],a[u+1],a[u+2],r),l.setFromEuler(h),s!==void 0&&l.premultiply(s),n!==void 0&&l.multiply(n),u>2&&new ve().fromArray(p,(u-3)/3*4).dot(l)<0&&l.set(-l.x,-l.y,-l.z,-l.w),l.toArray(p,u/3*4);return new an(e+".quaternion",i,p)}generateMorphTrack(e){const t=e.DeformPercent.curves.morph,s=t.values.map(function(r){return r/100}),n=_e.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];return new bn(e.modelName+".morphTargetInfluences["+n+"]",t.times,s)}getTimesForAllAxes(e){let t=[];if(e.x!==void 0&&(t=t.concat(e.x.times)),e.y!==void 0&&(t=t.concat(e.y.times)),e.z!==void 0&&(t=t.concat(e.z.times)),t=t.sort(function(s,n){return s-n}),t.length>1){let s=1,n=t[0];for(let r=1;r<t.length;r++){const i=t[r];i!==n&&(t[s]=i,n=i,s++)}t=t.slice(0,s)}return t}getKeyframeTrackValues(e,t,s){const n=s,r=[];let i=-1,a=-1,l=-1;return e.forEach(function(h){if(t.x&&(i=t.x.times.indexOf(h)),t.y&&(a=t.y.times.indexOf(h)),t.z&&(l=t.z.times.indexOf(h)),i!==-1){const p=t.x.values[i];r.push(p),n[0]=p}else r.push(n[0]);if(a!==-1){const p=t.y.values[a];r.push(p),n[1]=p}else r.push(n[1]);if(l!==-1){const p=t.z.values[l];r.push(p),n[2]=p}else r.push(n[2])}),r}interpolateRotations(e,t,s,n){const r=[],i=[];r.push(e.times[0]),i.push(Se.degToRad(e.values[0])),i.push(Se.degToRad(t.values[0])),i.push(Se.degToRad(s.values[0]));for(let a=1;a<e.values.length;a++){const l=[e.values[a-1],t.values[a-1],s.values[a-1]];if(isNaN(l[0])||isNaN(l[1])||isNaN(l[2]))continue;const h=l.map(Se.degToRad),p=[e.values[a],t.values[a],s.values[a]];if(isNaN(p[0])||isNaN(p[1])||isNaN(p[2]))continue;const u=p.map(Se.degToRad),d=[p[0]-l[0],p[1]-l[1],p[2]-l[2]],g=[Math.abs(d[0]),Math.abs(d[1]),Math.abs(d[2])];if(g[0]>=180||g[1]>=180||g[2]>=180){const x=Math.max(...g)/180,v=new We(...h,n),R=new We(...u,n),_=new ve().setFromEuler(v),I=new ve().setFromEuler(R);_.dot(I)&&I.set(-I.x,-I.y,-I.z,-I.w);const O=e.times[a-1],H=e.times[a]-O,j=new ve,W=new We;for(let C=0;C<1;C+=1/x)j.copy(_.clone().slerp(I.clone(),C)),r.push(O+C*H),W.setFromQuaternion(j,n),i.push(W.x),i.push(W.y),i.push(W.z)}else r.push(e.times[a]),i.push(Se.degToRad(e.values[a])),i.push(Se.degToRad(t.values[a])),i.push(Se.degToRad(s.values[a]))}return[r,i]}}class Di{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(e){this.nodeStack.push(e),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(e,t){this.currentProp=e,this.currentPropName=t}parse(e){this.currentIndent=0,this.allNodes=new Cs,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const t=this,s=e.split(/[\r\n]+/);return s.forEach(function(n,r){const i=n.match(/^[\s\t]*;/),a=n.match(/^[\s\t]*$/);if(i||a)return;const l=n.match("^\\t{"+t.currentIndent+"}(\\w+):(.*){",""),h=n.match("^\\t{"+t.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),p=n.match("^\\t{"+(t.currentIndent-1)+"}}");l?t.parseNodeBegin(n,l):h?t.parseNodeProperty(n,h,s[++r]):p?t.popStack():n.match(/^[^\s\t}]/)&&t.parseNodePropertyContinued(n)}),this.allNodes}parseNodeBegin(e,t){const s=t[1].trim().replace(/^"/,"").replace(/"$/,""),n=t[2].split(",").map(function(l){return l.trim().replace(/^"/,"").replace(/"$/,"")}),r={name:s},i=this.parseNodeAttr(n),a=this.getCurrentNode();this.currentIndent===0?this.allNodes.add(s,r):s in a?(s==="PoseNode"?a.PoseNode.push(r):a[s].id!==void 0&&(a[s]={},a[s][a[s].id]=a[s]),i.id!==""&&(a[s][i.id]=r)):typeof i.id=="number"?(a[s]={},a[s][i.id]=r):s!=="Properties70"&&(s==="PoseNode"?a[s]=[r]:a[s]=r),typeof i.id=="number"&&(r.id=i.id),i.name!==""&&(r.attrName=i.name),i.type!==""&&(r.attrType=i.type),this.pushStack(r)}parseNodeAttr(e){let t=e[0];e[0]!==""&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0]));let s="",n="";return e.length>1&&(s=e[1].replace(/^(\w+)::/,""),n=e[2]),{id:t,name:s,type:n}}parseNodeProperty(e,t,s){let n=t[1].replace(/^"/,"").replace(/"$/,"").trim(),r=t[2].replace(/^"/,"").replace(/"$/,"").trim();n==="Content"&&r===","&&(r=s.replace(/"/g,"").replace(/,$/,"").trim());const i=this.getCurrentNode();if(i.name==="Properties70"){this.parseNodeSpecialProperty(e,n,r);return}if(n==="C"){const l=r.split(",").slice(1),h=parseInt(l[0]),p=parseInt(l[1]);let u=r.split(",").slice(3);u=u.map(function(d){return d.trim().replace(/^"/,"")}),n="connections",r=[h,p],Ui(r,u),i[n]===void 0&&(i[n]=[])}n==="Node"&&(i.id=r),n in i&&Array.isArray(i[n])?i[n].push(r):n!=="a"?i[n]=r:i.a=r,this.setCurrentProp(i,n),n==="a"&&r.slice(-1)!==","&&(i.a=gn(r))}parseNodePropertyContinued(e){const t=this.getCurrentNode();t.a+=e,e.slice(-1)!==","&&(t.a=gn(t.a))}parseNodeSpecialProperty(e,t,s){const n=s.split('",').map(function(p){return p.trim().replace(/^\"/,"").replace(/\s/,"_")}),r=n[0],i=n[1],a=n[2],l=n[3];let h=n[4];switch(i){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":h=parseFloat(h);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":h=gn(h);break}this.getPrevNode()[r]={type:i,type2:a,flag:l,value:h},this.setCurrentProp(this.getPrevNode(),r)}}class Fi{parse(e){const t=new Xn(e);t.skip(23);const s=t.getUint32();if(s<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+s);const n=new Cs;for(;!this.endOfContent(t);){const r=this.parseNode(t,s);r!==null&&n.add(r.name,r)}return n}endOfContent(e){return e.size()%16===0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()}parseNode(e,t){const s={},n=t>=7500?e.getUint64():e.getUint32(),r=t>=7500?e.getUint64():e.getUint32();t>=7500?e.getUint64():e.getUint32();const i=e.getUint8(),a=e.getString(i);if(n===0)return null;const l=[];for(let d=0;d<r;d++)l.push(this.parseProperty(e));const h=l.length>0?l[0]:"",p=l.length>1?l[1]:"",u=l.length>2?l[2]:"";for(s.singleProperty=r===1&&e.getOffset()===n;n>e.getOffset();){const d=this.parseNode(e,t);d!==null&&this.parseSubNode(a,s,d)}return s.propertyList=l,typeof h=="number"&&(s.id=h),p!==""&&(s.attrName=p),u!==""&&(s.attrType=u),a!==""&&(s.name=a),s}parseSubNode(e,t,s){if(s.singleProperty===!0){const n=s.propertyList[0];Array.isArray(n)?(t[s.name]=s,s.a=n):t[s.name]=n}else if(e==="Connections"&&s.name==="C"){const n=[];s.propertyList.forEach(function(r,i){i!==0&&n.push(r)}),t.connections===void 0&&(t.connections=[]),t.connections.push(n)}else if(s.name==="Properties70")Object.keys(s).forEach(function(r){t[r]=s[r]});else if(e==="Properties70"&&s.name==="P"){let n=s.propertyList[0],r=s.propertyList[1];const i=s.propertyList[2],a=s.propertyList[3];let l;n.indexOf("Lcl ")===0&&(n=n.replace("Lcl ","Lcl_")),r.indexOf("Lcl ")===0&&(r=r.replace("Lcl ","Lcl_")),r==="Color"||r==="ColorRGB"||r==="Vector"||r==="Vector3D"||r.indexOf("Lcl_")===0?l=[s.propertyList[4],s.propertyList[5],s.propertyList[6]]:l=s.propertyList[4],t[n]={type:r,type2:i,flag:a,value:l}}else t[s.name]===void 0?typeof s.id=="number"?(t[s.name]={},t[s.name][s.id]=s):t[s.name]=s:s.name==="PoseNode"?(Array.isArray(t[s.name])||(t[s.name]=[t[s.name]]),t[s.name].push(s)):t[s.name][s.id]===void 0&&(t[s.name][s.id]=s)}parseProperty(e){const t=e.getString(1);let s;switch(t){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":return s=e.getUint32(),e.getArrayBuffer(s);case"S":return s=e.getUint32(),e.getString(s);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const n=e.getUint32(),r=e.getUint32(),i=e.getUint32();if(r===0)switch(t){case"b":case"c":return e.getBooleanArray(n);case"d":return e.getFloat64Array(n);case"f":return e.getFloat32Array(n);case"i":return e.getInt32Array(n);case"l":return e.getInt64Array(n)}const a=Ut(new Uint8Array(e.getArrayBuffer(i))),l=new Xn(a.buffer);switch(t){case"b":case"c":return l.getBooleanArray(n);case"d":return l.getFloat64Array(n);case"f":return l.getFloat32Array(n);case"i":return l.getInt32Array(n);case"l":return l.getInt64Array(n)}break;default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}class Xn{constructor(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=t!==void 0?t:!0,this._textDecoder=new TextDecoder}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(e){this.offset+=e}getBoolean(){return(this.getUint8()&1)===1}getBooleanArray(e){const t=[];for(let s=0;s<e;s++)t.push(this.getBoolean());return t}getUint8(){const e=this.dv.getUint8(this.offset);return this.offset+=1,e}getInt16(){const e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e}getInt32(){const e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e}getInt32Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getInt32());return t}getUint32(){const e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e}getInt64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t&2147483648?(t=~t&4294967295,e=~e&4294967295,e===4294967295&&(t=t+1&4294967295),e=e+1&4294967295,-(t*4294967296+e)):t*4294967296+e}getInt64Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getInt64());return t}getUint64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t*4294967296+e}getFloat32(){const e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e}getFloat32Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getFloat32());return t}getFloat64(){const e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e}getFloat64Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getFloat64());return t}getArrayBuffer(e){const t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}getString(e){const t=this.offset;let s=new Uint8Array(this.dv.buffer,t,e);this.skip(e);const n=s.indexOf(0);return n>=0&&(s=new Uint8Array(this.dv.buffer,t,n)),this._textDecoder.decode(s)}}class Cs{add(e,t){this[e]=t}}function Oi(c){const e="Kaydara FBX Binary  \0";return c.byteLength>=e.length&&e===Ds(c,0,e.length)}function Ni(c){const e=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let t=0;function s(n){const r=c[n-1];return c=c.slice(t+n),t++,r}for(let n=0;n<e.length;++n)if(s(1)===e[n])return!1;return!0}function Vn(c){const e=/FBXVersion: (\d+)/,t=c.match(e);if(t)return parseInt(t[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function ki(c){return c/46186158e3}const Bi=[];function en(c,e,t,s){let n;switch(s.mappingType){case"ByPolygonVertex":n=c;break;case"ByPolygon":n=e;break;case"ByVertice":n=t;break;case"AllSame":n=s.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+s.mappingType)}s.referenceType==="IndexToDirect"&&(n=s.indices[n]);const r=n*s.dataSize,i=r+s.dataSize;return Hi(Bi,s.buffer,r,i)}const mn=new We,vt=new L;function Ps(c){const e=new oe,t=new oe,s=new oe,n=new oe,r=new oe,i=new oe,a=new oe,l=new oe,h=new oe,p=new oe,u=new oe,d=new oe,g=c.inheritType?c.inheritType:0;if(c.translation&&e.setPosition(vt.fromArray(c.translation)),c.preRotation){const X=c.preRotation.map(Se.degToRad);X.push(c.eulerOrder||We.DEFAULT_ORDER),t.makeRotationFromEuler(mn.fromArray(X))}if(c.rotation){const X=c.rotation.map(Se.degToRad);X.push(c.eulerOrder||We.DEFAULT_ORDER),s.makeRotationFromEuler(mn.fromArray(X))}if(c.postRotation){const X=c.postRotation.map(Se.degToRad);X.push(c.eulerOrder||We.DEFAULT_ORDER),n.makeRotationFromEuler(mn.fromArray(X)),n.invert()}c.scale&&r.scale(vt.fromArray(c.scale)),c.scalingOffset&&a.setPosition(vt.fromArray(c.scalingOffset)),c.scalingPivot&&i.setPosition(vt.fromArray(c.scalingPivot)),c.rotationOffset&&l.setPosition(vt.fromArray(c.rotationOffset)),c.rotationPivot&&h.setPosition(vt.fromArray(c.rotationPivot)),c.parentMatrixWorld&&(u.copy(c.parentMatrix),p.copy(c.parentMatrixWorld));const T=t.clone().multiply(s).multiply(n),x=new oe;x.extractRotation(p);const v=new oe;v.copyPosition(p);const R=v.clone().invert().multiply(p),_=x.clone().invert().multiply(R),I=r,O=new oe;if(g===0)O.copy(x).multiply(T).multiply(_).multiply(I);else if(g===1)O.copy(x).multiply(_).multiply(T).multiply(I);else{const Y=new oe().scale(new L().setFromMatrixScale(u)).clone().invert(),$=_.clone().multiply(Y);O.copy(x).multiply(T).multiply($).multiply(I)}const H=h.clone().invert(),j=i.clone().invert();let W=e.clone().multiply(l).multiply(h).multiply(t).multiply(s).multiply(n).multiply(H).multiply(a).multiply(i).multiply(r).multiply(j);const C=new oe().copyPosition(W),z=p.clone().multiply(C);return d.copyPosition(z),W=d.clone().multiply(O),W.premultiply(p.invert()),W}function Ls(c){c=c||0;const e=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return c===6?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),e[0]):e[c]}function gn(c){return c.split(",").map(function(t){return parseFloat(t)})}function Ds(c,e,t){return e===void 0&&(e=0),t===void 0&&(t=c.byteLength),new TextDecoder().decode(new Uint8Array(c,e,t))}function Ui(c,e){for(let t=0,s=c.length,n=e.length;t<n;t++,s++)c[s]=e[t]}function Hi(c,e,t,s){for(let n=t,r=0;n<s;n++,r++)c[r]=e[n];return c}function Zn(c,e){if(e===vr)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),c;if(e===Rn||e===hs){let t=c.getIndex();if(t===null){const i=[],a=c.getAttribute("position");if(a!==void 0){for(let l=0;l<a.count;l++)i.push(l);c.setIndex(i),t=c.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),c}const s=t.count-2,n=[];if(e===Rn)for(let i=1;i<=s;i++)n.push(t.getX(0)),n.push(t.getX(i)),n.push(t.getX(i+1));else for(let i=0;i<s;i++)i%2===0?(n.push(t.getX(i)),n.push(t.getX(i+1)),n.push(t.getX(i+2))):(n.push(t.getX(i+2)),n.push(t.getX(i+1)),n.push(t.getX(i)));n.length/3!==s&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const r=c.clone();return r.setIndex(n),r.clearGroups(),r}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),c}class Gi extends on{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new ji(t)}),this.register(function(t){return new Yi(t)}),this.register(function(t){return new no(t)}),this.register(function(t){return new so(t)}),this.register(function(t){return new ro(t)}),this.register(function(t){return new Wi(t)}),this.register(function(t){return new Ki(t)}),this.register(function(t){return new qi(t)}),this.register(function(t){return new $i(t)}),this.register(function(t){return new Zi(t)}),this.register(function(t){return new Ji(t)}),this.register(function(t){return new Qi(t)}),this.register(function(t){return new to(t)}),this.register(function(t){return new eo(t)}),this.register(function(t){return new Xi(t)}),this.register(function(t){return new io(t)}),this.register(function(t){return new oo(t)})}load(e,t,s,n){const r=this;let i;if(this.resourcePath!=="")i=this.resourcePath;else if(this.path!==""){const h=St.extractUrlBase(e);i=St.resolveURL(h,this.path)}else i=St.extractUrlBase(e);this.manager.itemStart(e);const a=function(h){n?n(h):console.error(h),r.manager.itemError(e),r.manager.itemEnd(e)},l=new Pn(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,function(h){try{r.parse(h,i,function(p){t(p),r.manager.itemEnd(e)},a)}catch(p){a(p)}},s,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s,n){let r;const i={},a={},l=new TextDecoder;if(typeof e=="string")r=JSON.parse(e);else if(e instanceof ArrayBuffer)if(l.decode(new Uint8Array(e,0,4))===Fs){try{i[ee.KHR_BINARY_GLTF]=new ao(e)}catch(u){n&&n(u);return}r=JSON.parse(i[ee.KHR_BINARY_GLTF].content)}else r=JSON.parse(l.decode(e));else r=e;if(r.asset===void 0||r.asset.version[0]<2){n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const h=new xo(r,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});h.fileLoader.setRequestHeader(this.requestHeader);for(let p=0;p<this.pluginCallbacks.length;p++){const u=this.pluginCallbacks[p](h);u.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),a[u.name]=u,i[u.name]=!0}if(r.extensionsUsed)for(let p=0;p<r.extensionsUsed.length;++p){const u=r.extensionsUsed[p],d=r.extensionsRequired||[];switch(u){case ee.KHR_MATERIALS_UNLIT:i[u]=new Vi;break;case ee.KHR_DRACO_MESH_COMPRESSION:i[u]=new lo(r,this.dracoLoader);break;case ee.KHR_TEXTURE_TRANSFORM:i[u]=new co;break;case ee.KHR_MESH_QUANTIZATION:i[u]=new uo;break;default:d.indexOf(u)>=0&&a[u]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+u+'".')}}h.setExtensions(i),h.setPlugins(a),h.parse(s,n)}parseAsync(e,t){const s=this;return new Promise(function(n,r){s.parse(e,t,n,r)})}}function zi(){let c={};return{get:function(e){return c[e]},add:function(e,t){c[e]=t},remove:function(e){delete c[e]},removeAll:function(){c={}}}}const ee={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Xi{constructor(e){this.parser=e,this.name=ee.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let s=0,n=t.length;s<n;s++){const r=t[s];r.extensions&&r.extensions[this.name]&&r.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,r.extensions[this.name].light)}}_loadLight(e){const t=this.parser,s="light:"+e;let n=t.cache.get(s);if(n)return n;const r=t.json,l=((r.extensions&&r.extensions[this.name]||{}).lights||[])[e];let h;const p=new we(16777215);l.color!==void 0&&p.setRGB(l.color[0],l.color[1],l.color[2],je);const u=l.range!==void 0?l.range:0;switch(l.type){case"directional":h=new as(p),h.target.position.set(0,0,-1),h.add(h.target);break;case"point":h=new Sn(p),h.distance=u;break;case"spot":h=new os(p),h.distance=u,l.spot=l.spot||{},l.spot.innerConeAngle=l.spot.innerConeAngle!==void 0?l.spot.innerConeAngle:0,l.spot.outerConeAngle=l.spot.outerConeAngle!==void 0?l.spot.outerConeAngle:Math.PI/4,h.angle=l.spot.outerConeAngle,h.penumbra=1-l.spot.innerConeAngle/l.spot.outerConeAngle,h.target.position.set(0,0,-1),h.add(h.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+l.type)}return h.position.set(0,0,0),h.decay=2,nt(h,l),l.intensity!==void 0&&(h.intensity=l.intensity),h.name=t.createUniqueName(l.name||"light_"+e),n=Promise.resolve(h),t.cache.add(s,n),n}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,s=this.parser,r=s.json.nodes[e],a=(r.extensions&&r.extensions[this.name]||{}).light;return a===void 0?null:this._loadLight(a).then(function(l){return s._getNodeRef(t.cache,a,l)})}}class Vi{constructor(){this.name=ee.KHR_MATERIALS_UNLIT}getMaterialType(){return Ve}extendParams(e,t,s){const n=[];e.color=new we(1,1,1),e.opacity=1;const r=t.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){const i=r.baseColorFactor;e.color.setRGB(i[0],i[1],i[2],je),e.opacity=i[3]}r.baseColorTexture!==void 0&&n.push(s.assignTexture(e,"map",r.baseColorTexture,st))}return Promise.all(n)}}class Zi{constructor(e){this.parser=e,this.name=ee.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=n.extensions[this.name].emissiveStrength;return r!==void 0&&(t.emissiveIntensity=r),Promise.resolve()}}class ji{constructor(e){this.parser=e,this.name=ee.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Je}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];if(i.clearcoatFactor!==void 0&&(t.clearcoat=i.clearcoatFactor),i.clearcoatTexture!==void 0&&r.push(s.assignTexture(t,"clearcoatMap",i.clearcoatTexture)),i.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=i.clearcoatRoughnessFactor),i.clearcoatRoughnessTexture!==void 0&&r.push(s.assignTexture(t,"clearcoatRoughnessMap",i.clearcoatRoughnessTexture)),i.clearcoatNormalTexture!==void 0&&(r.push(s.assignTexture(t,"clearcoatNormalMap",i.clearcoatNormalTexture)),i.clearcoatNormalTexture.scale!==void 0)){const a=i.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new Me(a,a)}return Promise.all(r)}}class Yi{constructor(e){this.parser=e,this.name=ee.KHR_MATERIALS_DISPERSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Je}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=n.extensions[this.name];return t.dispersion=r.dispersion!==void 0?r.dispersion:0,Promise.resolve()}}class Qi{constructor(e){this.parser=e,this.name=ee.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Je}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];return i.iridescenceFactor!==void 0&&(t.iridescence=i.iridescenceFactor),i.iridescenceTexture!==void 0&&r.push(s.assignTexture(t,"iridescenceMap",i.iridescenceTexture)),i.iridescenceIor!==void 0&&(t.iridescenceIOR=i.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),i.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=i.iridescenceThicknessMinimum),i.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=i.iridescenceThicknessMaximum),i.iridescenceThicknessTexture!==void 0&&r.push(s.assignTexture(t,"iridescenceThicknessMap",i.iridescenceThicknessTexture)),Promise.all(r)}}class Wi{constructor(e){this.parser=e,this.name=ee.KHR_MATERIALS_SHEEN}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Je}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[];t.sheenColor=new we(0,0,0),t.sheenRoughness=0,t.sheen=1;const i=n.extensions[this.name];if(i.sheenColorFactor!==void 0){const a=i.sheenColorFactor;t.sheenColor.setRGB(a[0],a[1],a[2],je)}return i.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=i.sheenRoughnessFactor),i.sheenColorTexture!==void 0&&r.push(s.assignTexture(t,"sheenColorMap",i.sheenColorTexture,st)),i.sheenRoughnessTexture!==void 0&&r.push(s.assignTexture(t,"sheenRoughnessMap",i.sheenRoughnessTexture)),Promise.all(r)}}class Ki{constructor(e){this.parser=e,this.name=ee.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Je}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];return i.transmissionFactor!==void 0&&(t.transmission=i.transmissionFactor),i.transmissionTexture!==void 0&&r.push(s.assignTexture(t,"transmissionMap",i.transmissionTexture)),Promise.all(r)}}class qi{constructor(e){this.parser=e,this.name=ee.KHR_MATERIALS_VOLUME}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Je}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];t.thickness=i.thicknessFactor!==void 0?i.thicknessFactor:0,i.thicknessTexture!==void 0&&r.push(s.assignTexture(t,"thicknessMap",i.thicknessTexture)),t.attenuationDistance=i.attenuationDistance||1/0;const a=i.attenuationColor||[1,1,1];return t.attenuationColor=new we().setRGB(a[0],a[1],a[2],je),Promise.all(r)}}class $i{constructor(e){this.parser=e,this.name=ee.KHR_MATERIALS_IOR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Je}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=n.extensions[this.name];return t.ior=r.ior!==void 0?r.ior:1.5,Promise.resolve()}}class Ji{constructor(e){this.parser=e,this.name=ee.KHR_MATERIALS_SPECULAR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Je}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];t.specularIntensity=i.specularFactor!==void 0?i.specularFactor:1,i.specularTexture!==void 0&&r.push(s.assignTexture(t,"specularIntensityMap",i.specularTexture));const a=i.specularColorFactor||[1,1,1];return t.specularColor=new we().setRGB(a[0],a[1],a[2],je),i.specularColorTexture!==void 0&&r.push(s.assignTexture(t,"specularColorMap",i.specularColorTexture,st)),Promise.all(r)}}class eo{constructor(e){this.parser=e,this.name=ee.EXT_MATERIALS_BUMP}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Je}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];return t.bumpScale=i.bumpFactor!==void 0?i.bumpFactor:1,i.bumpTexture!==void 0&&r.push(s.assignTexture(t,"bumpMap",i.bumpTexture)),Promise.all(r)}}class to{constructor(e){this.parser=e,this.name=ee.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Je}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const r=[],i=n.extensions[this.name];return i.anisotropyStrength!==void 0&&(t.anisotropy=i.anisotropyStrength),i.anisotropyRotation!==void 0&&(t.anisotropyRotation=i.anisotropyRotation),i.anisotropyTexture!==void 0&&r.push(s.assignTexture(t,"anisotropyMap",i.anisotropyTexture)),Promise.all(r)}}class no{constructor(e){this.parser=e,this.name=ee.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,s=t.json,n=s.textures[e];if(!n.extensions||!n.extensions[this.name])return null;const r=n.extensions[this.name],i=t.options.ktx2Loader;if(!i){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,r.source,i)}}class so{constructor(e){this.parser=e,this.name=ee.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,n=s.json,r=n.textures[e];if(!r.extensions||!r.extensions[t])return null;const i=r.extensions[t],a=n.images[i.source];let l=s.textureLoader;if(a.uri){const h=s.options.manager.getHandler(a.uri);h!==null&&(l=h)}return this.detectSupport().then(function(h){if(h)return s.loadTextureImage(e,i.source,l);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class ro{constructor(e){this.parser=e,this.name=ee.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,n=s.json,r=n.textures[e];if(!r.extensions||!r.extensions[t])return null;const i=r.extensions[t],a=n.images[i.source];let l=s.textureLoader;if(a.uri){const h=s.options.manager.getHandler(a.uri);h!==null&&(l=h)}return this.detectSupport().then(function(h){if(h)return s.loadTextureImage(e,i.source,l);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class io{constructor(e){this.name=ee.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,s=t.bufferViews[e];if(s.extensions&&s.extensions[this.name]){const n=s.extensions[this.name],r=this.parser.getDependency("buffer",n.buffer),i=this.parser.options.meshoptDecoder;if(!i||!i.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return r.then(function(a){const l=n.byteOffset||0,h=n.byteLength||0,p=n.count,u=n.byteStride,d=new Uint8Array(a,l,h);return i.decodeGltfBufferAsync?i.decodeGltfBufferAsync(p,u,d,n.mode,n.filter).then(function(g){return g.buffer}):i.ready.then(function(){const g=new ArrayBuffer(p*u);return i.decodeGltfBuffer(new Uint8Array(g),p,u,d,n.mode,n.filter),g})})}else return null}}class oo{constructor(e){this.name=ee.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,s=t.nodes[e];if(!s.extensions||!s.extensions[this.name]||s.mesh===void 0)return null;const n=t.meshes[s.mesh];for(const h of n.primitives)if(h.mode!==Ge.TRIANGLES&&h.mode!==Ge.TRIANGLE_STRIP&&h.mode!==Ge.TRIANGLE_FAN&&h.mode!==void 0)return null;const i=s.extensions[this.name].attributes,a=[],l={};for(const h in i)a.push(this.parser.getDependency("accessor",i[h]).then(p=>(l[h]=p,l[h])));return a.length<1?null:(a.push(this.parser.createNodeMesh(e)),Promise.all(a).then(h=>{const p=h.pop(),u=p.isGroup?p.children:[p],d=h[0].count,g=[];for(const T of u){const x=new oe,v=new L,R=new ve,_=new L(1,1,1),I=new xr(T.geometry,T.material,d);for(let O=0;O<d;O++)l.TRANSLATION&&v.fromBufferAttribute(l.TRANSLATION,O),l.ROTATION&&R.fromBufferAttribute(l.ROTATION,O),l.SCALE&&_.fromBufferAttribute(l.SCALE,O),I.setMatrixAt(O,x.compose(v,R,_));for(const O in l)if(O==="_COLOR_0"){const H=l[O];I.instanceColor=new Ar(H.array,H.itemSize,H.normalized)}else O!=="TRANSLATION"&&O!=="ROTATION"&&O!=="SCALE"&&T.geometry.setAttribute(O,l[O]);ht.prototype.copy.call(I,T),this.parser.assignFinalMaterial(I),g.push(I)}return p.isGroup?(p.clear(),p.add(...g),p):g[0]}))}}const Fs="glTF",Nt=12,jn={JSON:1313821514,BIN:5130562};class ao{constructor(e){this.name=ee.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,Nt),s=new TextDecoder;if(this.header={magic:s.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==Fs)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-Nt,r=new DataView(e,Nt);let i=0;for(;i<n;){const a=r.getUint32(i,!0);i+=4;const l=r.getUint32(i,!0);if(i+=4,l===jn.JSON){const h=new Uint8Array(e,Nt+i,a);this.content=s.decode(h)}else if(l===jn.BIN){const h=Nt+i;this.body=e.slice(h,h+a)}i+=a}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class lo{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=ee.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const s=this.json,n=this.dracoLoader,r=e.extensions[this.name].bufferView,i=e.extensions[this.name].attributes,a={},l={},h={};for(const p in i){const u=_n[p]||p.toLowerCase();a[u]=i[p]}for(const p in e.attributes){const u=_n[p]||p.toLowerCase();if(i[p]!==void 0){const d=s.accessors[e.attributes[p]],g=Rt[d.componentType];h[u]=g.name,l[u]=d.normalized===!0}}return t.getDependency("bufferView",r).then(function(p){return new Promise(function(u,d){n.decodeDracoFile(p,function(g){for(const T in g.attributes){const x=g.attributes[T],v=l[T];v!==void 0&&(x.normalized=v)}u(g)},a,h,je,d)})})}}class co{constructor(){this.name=ee.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class uo{constructor(){this.name=ee.KHR_MESH_QUANTIZATION}}class Os extends Nr{constructor(e,t,s,n){super(e,t,s,n)}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,n=this.valueSize,r=e*n*3+n;for(let i=0;i!==n;i++)t[i]=s[r+i];return t}interpolate_(e,t,s,n){const r=this.resultBuffer,i=this.sampleValues,a=this.valueSize,l=a*2,h=a*3,p=n-t,u=(s-t)/p,d=u*u,g=d*u,T=e*h,x=T-h,v=-2*g+3*d,R=g-d,_=1-v,I=R-d+u;for(let O=0;O!==a;O++){const H=i[x+O+a],j=i[x+O+l]*p,W=i[T+O+a],C=i[T+O]*p;r[O]=_*H+I*j+v*W+R*C}return r}}const ho=new ve;class po extends Os{interpolate_(e,t,s,n){const r=super.interpolate_(e,t,s,n);return ho.fromArray(r).normalize().toArray(r),r}}const Ge={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},Rt={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Yn={9728:Rr,9729:It,9984:Ir,9985:_r,9986:Cr,9987:ps},Qn={33071:An,33648:Pr,10497:Ce},wn={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},_n={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},lt={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},fo={CUBICSPLINE:void 0,LINEAR:gs,STEP:Lr},yn={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function mo(c){return c.DefaultMaterial===void 0&&(c.DefaultMaterial=new ds({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Dr})),c.DefaultMaterial}function mt(c,e,t){for(const s in t.extensions)c[s]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[s]=t.extensions[s])}function nt(c,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(c.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function go(c,e,t){let s=!1,n=!1,r=!1;for(let h=0,p=e.length;h<p;h++){const u=e[h];if(u.POSITION!==void 0&&(s=!0),u.NORMAL!==void 0&&(n=!0),u.COLOR_0!==void 0&&(r=!0),s&&n&&r)break}if(!s&&!n&&!r)return Promise.resolve(c);const i=[],a=[],l=[];for(let h=0,p=e.length;h<p;h++){const u=e[h];if(s){const d=u.POSITION!==void 0?t.getDependency("accessor",u.POSITION):c.attributes.position;i.push(d)}if(n){const d=u.NORMAL!==void 0?t.getDependency("accessor",u.NORMAL):c.attributes.normal;a.push(d)}if(r){const d=u.COLOR_0!==void 0?t.getDependency("accessor",u.COLOR_0):c.attributes.color;l.push(d)}}return Promise.all([Promise.all(i),Promise.all(a),Promise.all(l)]).then(function(h){const p=h[0],u=h[1],d=h[2];return s&&(c.morphAttributes.position=p),n&&(c.morphAttributes.normal=u),r&&(c.morphAttributes.color=d),c.morphTargetsRelative=!0,c})}function wo(c,e){if(c.updateMorphTargets(),e.weights!==void 0)for(let t=0,s=e.weights.length;t<s;t++)c.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(c.morphTargetInfluences.length===t.length){c.morphTargetDictionary={};for(let s=0,n=t.length;s<n;s++)c.morphTargetDictionary[t[s]]=s}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function yo(c){let e;const t=c.extensions&&c.extensions[ee.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+Tn(t.attributes):e=c.indices+":"+Tn(c.attributes)+":"+c.mode,c.targets!==void 0)for(let s=0,n=c.targets.length;s<n;s++)e+=":"+Tn(c.targets[s]);return e}function Tn(c){let e="";const t=Object.keys(c).sort();for(let s=0,n=t.length;s<n;s++)e+=t[s]+":"+c[t[s]]+";";return e}function Cn(c){switch(c){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function To(c){return c.search(/\.jpe?g($|\?)/i)>0||c.search(/^data\:image\/jpeg/)===0?"image/jpeg":c.search(/\.webp($|\?)/i)>0||c.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const vo=new oe;class xo{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new zi,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let s=!1,n=!1,r=-1;typeof navigator<"u"&&(s=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,n=navigator.userAgent.indexOf("Firefox")>-1,r=n?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||s||n&&r<98?this.textureLoader=new _t(this.options.manager):this.textureLoader=new Er(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Pn(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const s=this,n=this.json,r=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(i){return i._markDefs&&i._markDefs()}),Promise.all(this._invokeAll(function(i){return i.beforeRoot&&i.beforeRoot()})).then(function(){return Promise.all([s.getDependencies("scene"),s.getDependencies("animation"),s.getDependencies("camera")])}).then(function(i){const a={scene:i[0][n.scene||0],scenes:i[0],animations:i[1],cameras:i[2],asset:n.asset,parser:s,userData:{}};return mt(r,a,n),nt(a,n),Promise.all(s._invokeAll(function(l){return l.afterRoot&&l.afterRoot(a)})).then(function(){for(const l of a.scenes)l.updateMatrixWorld();e(a)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],s=this.json.meshes||[];for(let n=0,r=t.length;n<r;n++){const i=t[n].joints;for(let a=0,l=i.length;a<l;a++)e[i[a]].isBone=!0}for(let n=0,r=e.length;n<r;n++){const i=e[n];i.mesh!==void 0&&(this._addNodeRef(this.meshCache,i.mesh),i.skin!==void 0&&(s[i.mesh].isSkinnedMesh=!0)),i.camera!==void 0&&this._addNodeRef(this.cameraCache,i.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,s){if(e.refs[t]<=1)return s;const n=s.clone(),r=(i,a)=>{const l=this.associations.get(i);l!=null&&this.associations.set(a,l);for(const[h,p]of i.children.entries())r(p,a.children[h])};return r(s,n),n.name+="_instance_"+e.uses[t]++,n}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let s=0;s<t.length;s++){const n=e(t[s]);if(n)return n}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const s=[];for(let n=0;n<t.length;n++){const r=e(t[n]);r&&s.push(r)}return s}getDependency(e,t){const s=e+":"+t;let n=this.cache.get(s);if(!n){switch(e){case"scene":n=this.loadScene(t);break;case"node":n=this._invokeOne(function(r){return r.loadNode&&r.loadNode(t)});break;case"mesh":n=this._invokeOne(function(r){return r.loadMesh&&r.loadMesh(t)});break;case"accessor":n=this.loadAccessor(t);break;case"bufferView":n=this._invokeOne(function(r){return r.loadBufferView&&r.loadBufferView(t)});break;case"buffer":n=this.loadBuffer(t);break;case"material":n=this._invokeOne(function(r){return r.loadMaterial&&r.loadMaterial(t)});break;case"texture":n=this._invokeOne(function(r){return r.loadTexture&&r.loadTexture(t)});break;case"skin":n=this.loadSkin(t);break;case"animation":n=this._invokeOne(function(r){return r.loadAnimation&&r.loadAnimation(t)});break;case"camera":n=this.loadCamera(t);break;default:if(n=this._invokeOne(function(r){return r!=this&&r.getDependency&&r.getDependency(e,t)}),!n)throw new Error("Unknown type: "+e);break}this.cache.add(s,n)}return n}getDependencies(e){let t=this.cache.get(e);if(!t){const s=this,n=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(n.map(function(r,i){return s.getDependency(e,i)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],s=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[ee.KHR_BINARY_GLTF].body);const n=this.options;return new Promise(function(r,i){s.load(St.resolveURL(t.uri,n.path),r,void 0,function(){i(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(s){const n=t.byteLength||0,r=t.byteOffset||0;return s.slice(r,r+n)})}loadAccessor(e){const t=this,s=this.json,n=this.json.accessors[e];if(n.bufferView===void 0&&n.sparse===void 0){const i=wn[n.type],a=Rt[n.componentType],l=n.normalized===!0,h=new a(n.count*i);return Promise.resolve(new pt(h,i,l))}const r=[];return n.bufferView!==void 0?r.push(this.getDependency("bufferView",n.bufferView)):r.push(null),n.sparse!==void 0&&(r.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(r).then(function(i){const a=i[0],l=wn[n.type],h=Rt[n.componentType],p=h.BYTES_PER_ELEMENT,u=p*l,d=n.byteOffset||0,g=n.bufferView!==void 0?s.bufferViews[n.bufferView].byteStride:void 0,T=n.normalized===!0;let x,v;if(g&&g!==u){const R=Math.floor(d/g),_="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+R+":"+n.count;let I=t.cache.get(_);I||(x=new h(a,R*g,n.count*g/p),I=new Sr(x,g/p),t.cache.add(_,I)),v=new Fr(I,l,d%g/p,T)}else a===null?x=new h(n.count*l):x=new h(a,d,n.count*l),v=new pt(x,l,T);if(n.sparse!==void 0){const R=wn.SCALAR,_=Rt[n.sparse.indices.componentType],I=n.sparse.indices.byteOffset||0,O=n.sparse.values.byteOffset||0,H=new _(i[1],I,n.sparse.count*R),j=new h(i[2],O,n.sparse.count*l);a!==null&&(v=new pt(v.array.slice(),v.itemSize,v.normalized));for(let W=0,C=H.length;W<C;W++){const z=H[W];if(v.setX(z,j[W*l]),l>=2&&v.setY(z,j[W*l+1]),l>=3&&v.setZ(z,j[W*l+2]),l>=4&&v.setW(z,j[W*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return v})}loadTexture(e){const t=this.json,s=this.options,r=t.textures[e].source,i=t.images[r];let a=this.textureLoader;if(i.uri){const l=s.manager.getHandler(i.uri);l!==null&&(a=l)}return this.loadTextureImage(e,r,a)}loadTextureImage(e,t,s){const n=this,r=this.json,i=r.textures[e],a=r.images[t],l=(a.uri||a.bufferView)+":"+i.sampler;if(this.textureCache[l])return this.textureCache[l];const h=this.loadImageSource(t,s).then(function(p){p.flipY=!1,p.name=i.name||a.name||"",p.name===""&&typeof a.uri=="string"&&a.uri.startsWith("data:image/")===!1&&(p.name=a.uri);const d=(r.samplers||{})[i.sampler]||{};return p.magFilter=Yn[d.magFilter]||It,p.minFilter=Yn[d.minFilter]||ps,p.wrapS=Qn[d.wrapS]||Ce,p.wrapT=Qn[d.wrapT]||Ce,n.associations.set(p,{textures:e}),p}).catch(function(){return null});return this.textureCache[l]=h,h}loadImageSource(e,t){const s=this,n=this.json,r=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(u=>u.clone());const i=n.images[e],a=self.URL||self.webkitURL;let l=i.uri||"",h=!1;if(i.bufferView!==void 0)l=s.getDependency("bufferView",i.bufferView).then(function(u){h=!0;const d=new Blob([u],{type:i.mimeType});return l=a.createObjectURL(d),l});else if(i.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const p=Promise.resolve(l).then(function(u){return new Promise(function(d,g){let T=d;t.isImageBitmapLoader===!0&&(T=function(x){const v=new Mt(x);v.needsUpdate=!0,d(v)}),t.load(St.resolveURL(u,r.path),T,void 0,g)})}).then(function(u){return h===!0&&a.revokeObjectURL(l),nt(u,i),u.userData.mimeType=i.mimeType||To(i.uri),u}).catch(function(u){throw console.error("THREE.GLTFLoader: Couldn't load texture",l),u});return this.sourceCache[e]=p,p}assignTexture(e,t,s,n){const r=this;return this.getDependency("texture",s.index).then(function(i){if(!i)return null;if(s.texCoord!==void 0&&s.texCoord>0&&(i=i.clone(),i.channel=s.texCoord),r.extensions[ee.KHR_TEXTURE_TRANSFORM]){const a=s.extensions!==void 0?s.extensions[ee.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const l=r.associations.get(i);i=r.extensions[ee.KHR_TEXTURE_TRANSFORM].extendTexture(i,a),r.associations.set(i,l)}}return n!==void 0&&(i.colorSpace=n),e[t]=i,i})}assignFinalMaterial(e){const t=e.geometry;let s=e.material;const n=t.attributes.tangent===void 0,r=t.attributes.color!==void 0,i=t.attributes.normal===void 0;if(e.isPoints){const a="PointsMaterial:"+s.uuid;let l=this.cache.get(a);l||(l=new fs,pn.prototype.copy.call(l,s),l.color.copy(s.color),l.map=s.map,l.sizeAttenuation=!1,this.cache.add(a,l)),s=l}else if(e.isLine){const a="LineBasicMaterial:"+s.uuid;let l=this.cache.get(a);l||(l=new Yt,pn.prototype.copy.call(l,s),l.color.copy(s.color),l.map=s.map,this.cache.add(a,l)),s=l}if(n||r||i){let a="ClonedMaterial:"+s.uuid+":";n&&(a+="derivative-tangents:"),r&&(a+="vertex-colors:"),i&&(a+="flat-shading:");let l=this.cache.get(a);l||(l=s.clone(),r&&(l.vertexColors=!0),i&&(l.flatShading=!0),n&&(l.normalScale&&(l.normalScale.y*=-1),l.clearcoatNormalScale&&(l.clearcoatNormalScale.y*=-1)),this.cache.add(a,l),this.associations.set(l,this.associations.get(s))),s=l}e.material=s}getMaterialType(){return ds}loadMaterial(e){const t=this,s=this.json,n=this.extensions,r=s.materials[e];let i;const a={},l=r.extensions||{},h=[];if(l[ee.KHR_MATERIALS_UNLIT]){const u=n[ee.KHR_MATERIALS_UNLIT];i=u.getMaterialType(),h.push(u.extendParams(a,r,t))}else{const u=r.pbrMetallicRoughness||{};if(a.color=new we(1,1,1),a.opacity=1,Array.isArray(u.baseColorFactor)){const d=u.baseColorFactor;a.color.setRGB(d[0],d[1],d[2],je),a.opacity=d[3]}u.baseColorTexture!==void 0&&h.push(t.assignTexture(a,"map",u.baseColorTexture,st)),a.metalness=u.metallicFactor!==void 0?u.metallicFactor:1,a.roughness=u.roughnessFactor!==void 0?u.roughnessFactor:1,u.metallicRoughnessTexture!==void 0&&(h.push(t.assignTexture(a,"metalnessMap",u.metallicRoughnessTexture)),h.push(t.assignTexture(a,"roughnessMap",u.metallicRoughnessTexture))),i=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(e)}),h.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(e,a)})))}r.doubleSided===!0&&(a.side=rt);const p=r.alphaMode||yn.OPAQUE;if(p===yn.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,p===yn.MASK&&(a.alphaTest=r.alphaCutoff!==void 0?r.alphaCutoff:.5)),r.normalTexture!==void 0&&i!==Ve&&(h.push(t.assignTexture(a,"normalMap",r.normalTexture)),a.normalScale=new Me(1,1),r.normalTexture.scale!==void 0)){const u=r.normalTexture.scale;a.normalScale.set(u,u)}if(r.occlusionTexture!==void 0&&i!==Ve&&(h.push(t.assignTexture(a,"aoMap",r.occlusionTexture)),r.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=r.occlusionTexture.strength)),r.emissiveFactor!==void 0&&i!==Ve){const u=r.emissiveFactor;a.emissive=new we().setRGB(u[0],u[1],u[2],je)}return r.emissiveTexture!==void 0&&i!==Ve&&h.push(t.assignTexture(a,"emissiveMap",r.emissiveTexture,st)),Promise.all(h).then(function(){const u=new i(a);return r.name&&(u.name=r.name),nt(u,r),t.associations.set(u,{materials:e}),r.extensions&&mt(n,u,r),u})}createUniqueName(e){const t=jt.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,s=this.extensions,n=this.primitiveCache;function r(a){return s[ee.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,t).then(function(l){return Wn(l,a,t)})}const i=[];for(let a=0,l=e.length;a<l;a++){const h=e[a],p=yo(h),u=n[p];if(u)i.push(u.promise);else{let d;h.extensions&&h.extensions[ee.KHR_DRACO_MESH_COMPRESSION]?d=r(h):d=Wn(new Ze,h,t),n[p]={primitive:h,promise:d},i.push(d)}}return Promise.all(i)}loadMesh(e){const t=this,s=this.json,n=this.extensions,r=s.meshes[e],i=r.primitives,a=[];for(let l=0,h=i.length;l<h;l++){const p=i[l].material===void 0?mo(this.cache):this.getDependency("material",i[l].material);a.push(p)}return a.push(t.loadGeometries(i)),Promise.all(a).then(function(l){const h=l.slice(0,l.length-1),p=l[l.length-1],u=[];for(let g=0,T=p.length;g<T;g++){const x=p[g],v=i[g];let R;const _=h[g];if(v.mode===Ge.TRIANGLES||v.mode===Ge.TRIANGLE_STRIP||v.mode===Ge.TRIANGLE_FAN||v.mode===void 0)R=r.isSkinnedMesh===!0?new ls(x,_):new F(x,_),R.isSkinnedMesh===!0&&R.normalizeSkinWeights(),v.mode===Ge.TRIANGLE_STRIP?R.geometry=Zn(R.geometry,hs):v.mode===Ge.TRIANGLE_FAN&&(R.geometry=Zn(R.geometry,Rn));else if(v.mode===Ge.LINES)R=new Mr(x,_);else if(v.mode===Ge.LINE_STRIP)R=new ze(x,_);else if(v.mode===Ge.LINE_LOOP)R=new br(x,_);else if(v.mode===Ge.POINTS)R=new ms(x,_);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+v.mode);Object.keys(R.geometry.morphAttributes).length>0&&wo(R,r),R.name=t.createUniqueName(r.name||"mesh_"+e),nt(R,r),v.extensions&&mt(n,R,v),t.assignFinalMaterial(R),u.push(R)}for(let g=0,T=u.length;g<T;g++)t.associations.set(u[g],{meshes:e,primitives:g});if(u.length===1)return r.extensions&&mt(n,u[0],r),u[0];const d=new Xt;r.extensions&&mt(n,d,r),t.associations.set(d,{meshes:e});for(let g=0,T=u.length;g<T;g++)d.add(u[g]);return d})}loadCamera(e){let t;const s=this.json.cameras[e],n=s[s.type];if(!n){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return s.type==="perspective"?t=new is(Se.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):s.type==="orthographic"&&(t=new rs(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),s.name&&(t.name=this.createUniqueName(s.name)),nt(t,s),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],s=[];for(let n=0,r=t.joints.length;n<r;n++)s.push(this._loadNodeShallow(t.joints[n]));return t.inverseBindMatrices!==void 0?s.push(this.getDependency("accessor",t.inverseBindMatrices)):s.push(null),Promise.all(s).then(function(n){const r=n.pop(),i=n,a=[],l=[];for(let h=0,p=i.length;h<p;h++){const u=i[h];if(u){a.push(u);const d=new oe;r!==null&&d.fromArray(r.array,h*16),l.push(d)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[h])}return new cs(a,l)})}loadAnimation(e){const t=this.json,s=this,n=t.animations[e],r=n.name?n.name:"animation_"+e,i=[],a=[],l=[],h=[],p=[];for(let u=0,d=n.channels.length;u<d;u++){const g=n.channels[u],T=n.samplers[g.sampler],x=g.target,v=x.node,R=n.parameters!==void 0?n.parameters[T.input]:T.input,_=n.parameters!==void 0?n.parameters[T.output]:T.output;x.node!==void 0&&(i.push(this.getDependency("node",v)),a.push(this.getDependency("accessor",R)),l.push(this.getDependency("accessor",_)),h.push(T),p.push(x))}return Promise.all([Promise.all(i),Promise.all(a),Promise.all(l),Promise.all(h),Promise.all(p)]).then(function(u){const d=u[0],g=u[1],T=u[2],x=u[3],v=u[4],R=[];for(let _=0,I=d.length;_<I;_++){const O=d[_],H=g[_],j=T[_],W=x[_],C=v[_];if(O===void 0)continue;O.updateMatrix&&O.updateMatrix();const z=s._createAnimationTracks(O,H,j,W,C);if(z)for(let X=0;X<z.length;X++)R.push(z[X])}return new us(r,void 0,R)})}createNodeMesh(e){const t=this.json,s=this,n=t.nodes[e];return n.mesh===void 0?null:s.getDependency("mesh",n.mesh).then(function(r){const i=s._getNodeRef(s.meshCache,n.mesh,r);return n.weights!==void 0&&i.traverse(function(a){if(a.isMesh)for(let l=0,h=n.weights.length;l<h;l++)a.morphTargetInfluences[l]=n.weights[l]}),i})}loadNode(e){const t=this.json,s=this,n=t.nodes[e],r=s._loadNodeShallow(e),i=[],a=n.children||[];for(let h=0,p=a.length;h<p;h++)i.push(s.getDependency("node",a[h]));const l=n.skin===void 0?Promise.resolve(null):s.getDependency("skin",n.skin);return Promise.all([r,Promise.all(i),l]).then(function(h){const p=h[0],u=h[1],d=h[2];d!==null&&p.traverse(function(g){g.isSkinnedMesh&&g.bind(d,vo)});for(let g=0,T=u.length;g<T;g++)p.add(u[g]);return p})}_loadNodeShallow(e){const t=this.json,s=this.extensions,n=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const r=t.nodes[e],i=r.name?n.createUniqueName(r.name):"",a=[],l=n._invokeOne(function(h){return h.createNodeMesh&&h.createNodeMesh(e)});return l&&a.push(l),r.camera!==void 0&&a.push(n.getDependency("camera",r.camera).then(function(h){return n._getNodeRef(n.cameraCache,r.camera,h)})),n._invokeAll(function(h){return h.createNodeAttachment&&h.createNodeAttachment(e)}).forEach(function(h){a.push(h)}),this.nodeCache[e]=Promise.all(a).then(function(h){let p;if(r.isBone===!0?p=new En:h.length>1?p=new Xt:h.length===1?p=h[0]:p=new ht,p!==h[0])for(let u=0,d=h.length;u<d;u++)p.add(h[u]);if(r.name&&(p.userData.name=r.name,p.name=i),nt(p,r),r.extensions&&mt(s,p,r),r.matrix!==void 0){const u=new oe;u.fromArray(r.matrix),p.applyMatrix4(u)}else r.translation!==void 0&&p.position.fromArray(r.translation),r.rotation!==void 0&&p.quaternion.fromArray(r.rotation),r.scale!==void 0&&p.scale.fromArray(r.scale);return n.associations.has(p)||n.associations.set(p,{}),n.associations.get(p).nodes=e,p}),this.nodeCache[e]}loadScene(e){const t=this.extensions,s=this.json.scenes[e],n=this,r=new Xt;s.name&&(r.name=n.createUniqueName(s.name)),nt(r,s),s.extensions&&mt(t,r,s);const i=s.nodes||[],a=[];for(let l=0,h=i.length;l<h;l++)a.push(n.getDependency("node",i[l]));return Promise.all(a).then(function(l){for(let p=0,u=l.length;p<u;p++)r.add(l[p]);const h=p=>{const u=new Map;for(const[d,g]of n.associations)(d instanceof pn||d instanceof Mt)&&u.set(d,g);return p.traverse(d=>{const g=n.associations.get(d);g!=null&&u.set(d,g)}),u};return n.associations=h(r),r})}_createAnimationTracks(e,t,s,n,r){const i=[],a=e.name?e.name:e.uuid,l=[];lt[r.path]===lt.weights?e.traverse(function(d){d.morphTargetInfluences&&l.push(d.name?d.name:d.uuid)}):l.push(a);let h;switch(lt[r.path]){case lt.weights:h=bn;break;case lt.rotation:h=an;break;case lt.position:case lt.scale:h=Mn;break;default:switch(s.itemSize){case 1:h=bn;break;case 2:case 3:default:h=Mn;break}break}const p=n.interpolation!==void 0?fo[n.interpolation]:gs,u=this._getArrayFromAccessor(s);for(let d=0,g=l.length;d<g;d++){const T=new h(l[d]+"."+lt[r.path],t.array,u,p);n.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(T),i.push(T)}return i}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const s=Cn(t.constructor),n=new Float32Array(t.length);for(let r=0,i=t.length;r<i;r++)n[r]=t[r]*s;t=n}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(s){const n=this instanceof an?po:Os;return new n(this.times,this.values,this.getValueSize()/3,s)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function Ao(c,e,t){const s=e.attributes,n=new ws;if(s.POSITION!==void 0){const a=t.json.accessors[s.POSITION],l=a.min,h=a.max;if(l!==void 0&&h!==void 0){if(n.set(new L(l[0],l[1],l[2]),new L(h[0],h[1],h[2])),a.normalized){const p=Cn(Rt[a.componentType]);n.min.multiplyScalar(p),n.max.multiplyScalar(p)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const r=e.targets;if(r!==void 0){const a=new L,l=new L;for(let h=0,p=r.length;h<p;h++){const u=r[h];if(u.POSITION!==void 0){const d=t.json.accessors[u.POSITION],g=d.min,T=d.max;if(g!==void 0&&T!==void 0){if(l.setX(Math.max(Math.abs(g[0]),Math.abs(T[0]))),l.setY(Math.max(Math.abs(g[1]),Math.abs(T[1]))),l.setZ(Math.max(Math.abs(g[2]),Math.abs(T[2]))),d.normalized){const x=Cn(Rt[d.componentType]);l.multiplyScalar(x)}a.max(l)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}n.expandByVector(a)}c.boundingBox=n;const i=new Or;n.getCenter(i.center),i.radius=n.min.distanceTo(n.max)/2,c.boundingSphere=i}function Wn(c,e,t){const s=e.attributes,n=[];function r(i,a){return t.getDependency("accessor",i).then(function(l){c.setAttribute(a,l)})}for(const i in s){const a=_n[i]||i.toLowerCase();a in c.attributes||n.push(r(s[i],a))}if(e.indices!==void 0&&!c.index){const i=t.getDependency("accessor",e.indices).then(function(a){c.setIndex(a)});n.push(i)}return Hn.workingColorSpace!==je&&"COLOR_0"in s&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Hn.workingColorSpace}" not supported.`),nt(c,e),Ao(c,e,t),Promise.all(n).then(function(){return e.targets!==void 0?go(c,e.targets,t):c})}class Eo extends As{constructor(e,t,s=null,n=null,r=null){super(),this.scene=e,this.camera=t,this.overrideMaterial=s,this.clearColor=n,this.clearAlpha=r,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new we}render(e,t,s){const n=e.autoClear;e.autoClear=!1;let r,i;this.overrideMaterial!==null&&(i=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor!==null&&(e.getClearColor(this._oldClearColor),e.setClearColor(this.clearColor,e.getClearAlpha())),this.clearAlpha!==null&&(r=e.getClearAlpha(),e.setClearAlpha(this.clearAlpha)),this.clearDepth==!0&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:s),this.clear===!0&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),this.clearColor!==null&&e.setClearColor(this._oldClearColor),this.clearAlpha!==null&&e.setClearAlpha(r),this.overrideMaterial!==null&&(this.scene.overrideMaterial=i),e.autoClear=n}}class ut extends As{constructor(e,t,s,n){super(),this.renderScene=t,this.renderCamera=s,this.selectedObjects=n!==void 0?n:[],this.visibleEdgeColor=new we(1,1,1),this.hiddenEdgeColor=new we(.1,.04,.02),this.edgeGlow=0,this.usePatternTexture=!1,this.edgeThickness=1,this.edgeStrength=3,this.downSampleRatio=2,this.pulsePeriod=0,this._visibilityCache=new Map,this.resolution=e!==void 0?new Me(e.x,e.y):new Me(256,256);const r=Math.round(this.resolution.x/this.downSampleRatio),i=Math.round(this.resolution.y/this.downSampleRatio);this.renderTargetMaskBuffer=new dt(this.resolution.x,this.resolution.y),this.renderTargetMaskBuffer.texture.name="OutlinePass.mask",this.renderTargetMaskBuffer.texture.generateMipmaps=!1,this.depthMaterial=new kr,this.depthMaterial.side=rt,this.depthMaterial.depthPacking=Br,this.depthMaterial.blending=Gn,this.prepareMaskMaterial=this.getPrepareMaskMaterial(),this.prepareMaskMaterial.side=rt,this.prepareMaskMaterial.fragmentShader=p(this.prepareMaskMaterial.fragmentShader,this.renderCamera),this.renderTargetDepthBuffer=new dt(this.resolution.x,this.resolution.y,{type:Le}),this.renderTargetDepthBuffer.texture.name="OutlinePass.depth",this.renderTargetDepthBuffer.texture.generateMipmaps=!1,this.renderTargetMaskDownSampleBuffer=new dt(r,i,{type:Le}),this.renderTargetMaskDownSampleBuffer.texture.name="OutlinePass.depthDownSample",this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps=!1,this.renderTargetBlurBuffer1=new dt(r,i,{type:Le}),this.renderTargetBlurBuffer1.texture.name="OutlinePass.blur1",this.renderTargetBlurBuffer1.texture.generateMipmaps=!1,this.renderTargetBlurBuffer2=new dt(Math.round(r/2),Math.round(i/2),{type:Le}),this.renderTargetBlurBuffer2.texture.name="OutlinePass.blur2",this.renderTargetBlurBuffer2.texture.generateMipmaps=!1,this.edgeDetectionMaterial=this.getEdgeDetectionMaterial(),this.renderTargetEdgeBuffer1=new dt(r,i,{type:Le}),this.renderTargetEdgeBuffer1.texture.name="OutlinePass.edge1",this.renderTargetEdgeBuffer1.texture.generateMipmaps=!1,this.renderTargetEdgeBuffer2=new dt(Math.round(r/2),Math.round(i/2),{type:Le}),this.renderTargetEdgeBuffer2.texture.name="OutlinePass.edge2",this.renderTargetEdgeBuffer2.texture.generateMipmaps=!1;const a=4,l=4;this.separableBlurMaterial1=this.getSeperableBlurMaterial(a),this.separableBlurMaterial1.uniforms.texSize.value.set(r,i),this.separableBlurMaterial1.uniforms.kernelRadius.value=1,this.separableBlurMaterial2=this.getSeperableBlurMaterial(l),this.separableBlurMaterial2.uniforms.texSize.value.set(Math.round(r/2),Math.round(i/2)),this.separableBlurMaterial2.uniforms.kernelRadius.value=l,this.overlayMaterial=this.getOverlayMaterial();const h=si;this.copyUniforms=Ur.clone(h.uniforms),this.materialCopy=new Ft({uniforms:this.copyUniforms,vertexShader:h.vertexShader,fragmentShader:h.fragmentShader,blending:Gn,depthTest:!1,depthWrite:!1}),this.enabled=!0,this.needsSwap=!1,this._oldClearColor=new we,this.oldClearAlpha=1,this.fsQuad=new ni(null),this.tempPulseColor1=new we,this.tempPulseColor2=new we,this.textureMatrix=new oe;function p(u,d){const g=d.isPerspectiveCamera?"perspective":"orthographic";return u.replace(/DEPTH_TO_VIEW_Z/g,g+"DepthToViewZ")}}dispose(){this.renderTargetMaskBuffer.dispose(),this.renderTargetDepthBuffer.dispose(),this.renderTargetMaskDownSampleBuffer.dispose(),this.renderTargetBlurBuffer1.dispose(),this.renderTargetBlurBuffer2.dispose(),this.renderTargetEdgeBuffer1.dispose(),this.renderTargetEdgeBuffer2.dispose(),this.depthMaterial.dispose(),this.prepareMaskMaterial.dispose(),this.edgeDetectionMaterial.dispose(),this.separableBlurMaterial1.dispose(),this.separableBlurMaterial2.dispose(),this.overlayMaterial.dispose(),this.materialCopy.dispose(),this.fsQuad.dispose()}setSize(e,t){this.renderTargetMaskBuffer.setSize(e,t),this.renderTargetDepthBuffer.setSize(e,t);let s=Math.round(e/this.downSampleRatio),n=Math.round(t/this.downSampleRatio);this.renderTargetMaskDownSampleBuffer.setSize(s,n),this.renderTargetBlurBuffer1.setSize(s,n),this.renderTargetEdgeBuffer1.setSize(s,n),this.separableBlurMaterial1.uniforms.texSize.value.set(s,n),s=Math.round(s/2),n=Math.round(n/2),this.renderTargetBlurBuffer2.setSize(s,n),this.renderTargetEdgeBuffer2.setSize(s,n),this.separableBlurMaterial2.uniforms.texSize.value.set(s,n)}changeVisibilityOfSelectedObjects(e){const t=this._visibilityCache;function s(n){n.isMesh&&(e===!0?n.visible=t.get(n):(t.set(n,n.visible),n.visible=e))}for(let n=0;n<this.selectedObjects.length;n++)this.selectedObjects[n].traverse(s)}changeVisibilityOfNonSelectedObjects(e){const t=this._visibilityCache,s=[];function n(i){i.isMesh&&s.push(i)}for(let i=0;i<this.selectedObjects.length;i++)this.selectedObjects[i].traverse(n);function r(i){if(i.isMesh||i.isSprite){let a=!1;for(let l=0;l<s.length;l++)if(s[l].id===i.id){a=!0;break}if(a===!1){const l=i.visible;(e===!1||t.get(i)===!0)&&(i.visible=e),t.set(i,l)}}else(i.isPoints||i.isLine)&&(e===!0?i.visible=t.get(i):(t.set(i,i.visible),i.visible=e))}this.renderScene.traverse(r)}updateTextureMatrix(){this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.textureMatrix.multiply(this.renderCamera.projectionMatrix),this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse)}render(e,t,s,n,r){if(this.selectedObjects.length>0){e.getClearColor(this._oldClearColor),this.oldClearAlpha=e.getClearAlpha();const i=e.autoClear;e.autoClear=!1,r&&e.state.buffers.stencil.setTest(!1),e.setClearColor(16777215,1),this.changeVisibilityOfSelectedObjects(!1);const a=this.renderScene.background;if(this.renderScene.background=null,this.renderScene.overrideMaterial=this.depthMaterial,e.setRenderTarget(this.renderTargetDepthBuffer),e.clear(),e.render(this.renderScene,this.renderCamera),this.changeVisibilityOfSelectedObjects(!0),this._visibilityCache.clear(),this.updateTextureMatrix(),this.changeVisibilityOfNonSelectedObjects(!1),this.renderScene.overrideMaterial=this.prepareMaskMaterial,this.prepareMaskMaterial.uniforms.cameraNearFar.value.set(this.renderCamera.near,this.renderCamera.far),this.prepareMaskMaterial.uniforms.depthTexture.value=this.renderTargetDepthBuffer.texture,this.prepareMaskMaterial.uniforms.textureMatrix.value=this.textureMatrix,e.setRenderTarget(this.renderTargetMaskBuffer),e.clear(),e.render(this.renderScene,this.renderCamera),this.renderScene.overrideMaterial=null,this.changeVisibilityOfNonSelectedObjects(!0),this._visibilityCache.clear(),this.renderScene.background=a,this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetMaskBuffer.texture,e.setRenderTarget(this.renderTargetMaskDownSampleBuffer),e.clear(),this.fsQuad.render(e),this.tempPulseColor1.copy(this.visibleEdgeColor),this.tempPulseColor2.copy(this.hiddenEdgeColor),this.pulsePeriod>0){const l=.625+Math.cos(performance.now()*.01/this.pulsePeriod)*.75/2;this.tempPulseColor1.multiplyScalar(l),this.tempPulseColor2.multiplyScalar(l)}this.fsQuad.material=this.edgeDetectionMaterial,this.edgeDetectionMaterial.uniforms.maskTexture.value=this.renderTargetMaskDownSampleBuffer.texture,this.edgeDetectionMaterial.uniforms.texSize.value.set(this.renderTargetMaskDownSampleBuffer.width,this.renderTargetMaskDownSampleBuffer.height),this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value=this.tempPulseColor1,this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value=this.tempPulseColor2,e.setRenderTarget(this.renderTargetEdgeBuffer1),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.separableBlurMaterial1,this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=ut.BlurDirectionX,this.separableBlurMaterial1.uniforms.kernelRadius.value=this.edgeThickness,e.setRenderTarget(this.renderTargetBlurBuffer1),e.clear(),this.fsQuad.render(e),this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetBlurBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=ut.BlurDirectionY,e.setRenderTarget(this.renderTargetEdgeBuffer1),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.separableBlurMaterial2,this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial2.uniforms.direction.value=ut.BlurDirectionX,e.setRenderTarget(this.renderTargetBlurBuffer2),e.clear(),this.fsQuad.render(e),this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetBlurBuffer2.texture,this.separableBlurMaterial2.uniforms.direction.value=ut.BlurDirectionY,e.setRenderTarget(this.renderTargetEdgeBuffer2),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.overlayMaterial,this.overlayMaterial.uniforms.maskTexture.value=this.renderTargetMaskBuffer.texture,this.overlayMaterial.uniforms.edgeTexture1.value=this.renderTargetEdgeBuffer1.texture,this.overlayMaterial.uniforms.edgeTexture2.value=this.renderTargetEdgeBuffer2.texture,this.overlayMaterial.uniforms.patternTexture.value=this.patternTexture,this.overlayMaterial.uniforms.edgeStrength.value=this.edgeStrength,this.overlayMaterial.uniforms.edgeGlow.value=this.edgeGlow,this.overlayMaterial.uniforms.usePatternTexture.value=this.usePatternTexture,r&&e.state.buffers.stencil.setTest(!0),e.setRenderTarget(s),this.fsQuad.render(e),e.setClearColor(this._oldClearColor,this.oldClearAlpha),e.autoClear=i}this.renderToScreen&&(this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=s.texture,e.setRenderTarget(null),this.fsQuad.render(e))}getPrepareMaskMaterial(){return new Ft({uniforms:{depthTexture:{value:null},cameraNearFar:{value:new Me(.5,.5)},textureMatrix:{value:null}},vertexShader:`#include <morphtarget_pars_vertex>
				#include <skinning_pars_vertex>

				varying vec4 projTexCoord;
				varying vec4 vPosition;
				uniform mat4 textureMatrix;

				void main() {

					#include <skinbase_vertex>
					#include <begin_vertex>
					#include <morphtarget_vertex>
					#include <skinning_vertex>
					#include <project_vertex>

					vPosition = mvPosition;

					vec4 worldPosition = vec4( transformed, 1.0 );

					#ifdef USE_INSTANCING

						worldPosition = instanceMatrix * worldPosition;

					#endif
					
					worldPosition = modelMatrix * worldPosition;

					projTexCoord = textureMatrix * worldPosition;

				}`,fragmentShader:`#include <packing>
				varying vec4 vPosition;
				varying vec4 projTexCoord;
				uniform sampler2D depthTexture;
				uniform vec2 cameraNearFar;

				void main() {

					float depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));
					float viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );
					float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;
					gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);

				}`})}getEdgeDetectionMaterial(){return new Ft({uniforms:{maskTexture:{value:null},texSize:{value:new Me(.5,.5)},visibleEdgeColor:{value:new L(1,1,1)},hiddenEdgeColor:{value:new L(1,1,1)}},vertexShader:`varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,fragmentShader:`varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform vec2 texSize;
				uniform vec3 visibleEdgeColor;
				uniform vec3 hiddenEdgeColor;

				void main() {
					vec2 invSize = 1.0 / texSize;
					vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);
					vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);
					vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);
					vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);
					vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);
					float diff1 = (c1.r - c2.r)*0.5;
					float diff2 = (c3.r - c4.r)*0.5;
					float d = length( vec2(diff1, diff2) );
					float a1 = min(c1.g, c2.g);
					float a2 = min(c3.g, c4.g);
					float visibilityFactor = min(a1, a2);
					vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;
					gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);
				}`})}getSeperableBlurMaterial(e){return new Ft({defines:{MAX_RADIUS:e},uniforms:{colorTexture:{value:null},texSize:{value:new Me(.5,.5)},direction:{value:new Me(.5,.5)},kernelRadius:{value:1}},vertexShader:`varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,fragmentShader:`#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;
				uniform float kernelRadius;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}

				void main() {
					vec2 invSize = 1.0 / texSize;
					float sigma = kernelRadius/2.0;
					float weightSum = gaussianPdf(0.0, sigma);
					vec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;
					vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);
					vec2 uvOffset = delta;
					for( int i = 1; i <= MAX_RADIUS; i ++ ) {
						float x = kernelRadius * float(i) / float(MAX_RADIUS);
						float w = gaussianPdf(x, sigma);
						vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);
						vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);
						diffuseSum += ((sample1 + sample2) * w);
						weightSum += (2.0 * w);
						uvOffset += delta;
					}
					gl_FragColor = diffuseSum/weightSum;
				}`})}getOverlayMaterial(){return new Ft({uniforms:{maskTexture:{value:null},edgeTexture1:{value:null},edgeTexture2:{value:null},patternTexture:{value:null},edgeStrength:{value:1},edgeGlow:{value:1},usePatternTexture:{value:0}},vertexShader:`varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,fragmentShader:`varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform sampler2D edgeTexture1;
				uniform sampler2D edgeTexture2;
				uniform sampler2D patternTexture;
				uniform float edgeStrength;
				uniform float edgeGlow;
				uniform bool usePatternTexture;

				void main() {
					vec4 edgeValue1 = texture2D(edgeTexture1, vUv);
					vec4 edgeValue2 = texture2D(edgeTexture2, vUv);
					vec4 maskColor = texture2D(maskTexture, vUv);
					vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);
					float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;
					vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;
					vec4 finalColor = edgeStrength * maskColor.r * edgeValue;
					if(usePatternTexture)
						finalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);
					gl_FragColor = finalColor;
				}`,blending:Hr,depthTest:!1,depthWrite:!1,transparent:!0})}}ut.BlurDirectionX=new Me(1,0);ut.BlurDirectionY=new Me(0,1);const So={name:"GammaCorrectionShader",uniforms:{tDiffuse:{value:null}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 tex = texture2D( tDiffuse, vUv );

			gl_FragColor = sRGBTransferOETF( tex );

		}`},Mo={name:"FXAAShader",uniforms:{tDiffuse:{value:null},resolution:{value:new Me(1/1024,1/512)}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`
		precision highp float;

		uniform sampler2D tDiffuse;

		uniform vec2 resolution;

		varying vec2 vUv;

		// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)

		//----------------------------------------------------------------------------------
		// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag
		// SDK Version: v3.00
		// Email:       gameworks@nvidia.com
		// Site:        http://developer.nvidia.com/
		//
		// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
		//
		// Redistribution and use in source and binary forms, with or without
		// modification, are permitted provided that the following conditions
		// are met:
		//  * Redistributions of source code must retain the above copyright
		//    notice, this list of conditions and the following disclaimer.
		//  * Redistributions in binary form must reproduce the above copyright
		//    notice, this list of conditions and the following disclaimer in the
		//    documentation and/or other materials provided with the distribution.
		//  * Neither the name of NVIDIA CORPORATION nor the names of its
		//    contributors may be used to endorse or promote products derived
		//    from this software without specific prior written permission.
		//
		// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY
		// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
		// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
		// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
		// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
		// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
		// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		//
		//----------------------------------------------------------------------------------

		#ifndef FXAA_DISCARD
			//
			// Only valid for PC OpenGL currently.
			// Probably will not work when FXAA_GREEN_AS_LUMA = 1.
			//
			// 1 = Use discard on pixels which don't need AA.
			//     For APIs which enable concurrent TEX+ROP from same surface.
			// 0 = Return unchanged color on pixels which don't need AA.
			//
			#define FXAA_DISCARD 0
		#endif

		/*--------------------------------------------------------------------------*/
		#define FxaaTexTop(t, p) texture2D(t, p, -100.0)
		#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), -100.0)
		/*--------------------------------------------------------------------------*/

		#define NUM_SAMPLES 5

		// assumes colors have premultipliedAlpha, so that the calculated color contrast is scaled by alpha
		float contrast( vec4 a, vec4 b ) {
			vec4 diff = abs( a - b );
			return max( max( max( diff.r, diff.g ), diff.b ), diff.a );
		}

		/*============================================================================

									FXAA3 QUALITY - PC

		============================================================================*/

		/*--------------------------------------------------------------------------*/
		vec4 FxaaPixelShader(
			vec2 posM,
			sampler2D tex,
			vec2 fxaaQualityRcpFrame,
			float fxaaQualityEdgeThreshold,
			float fxaaQualityinvEdgeThreshold
		) {
			vec4 rgbaM = FxaaTexTop(tex, posM);
			vec4 rgbaS = FxaaTexOff(tex, posM, vec2( 0.0, 1.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaE = FxaaTexOff(tex, posM, vec2( 1.0, 0.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaN = FxaaTexOff(tex, posM, vec2( 0.0,-1.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaW = FxaaTexOff(tex, posM, vec2(-1.0, 0.0), fxaaQualityRcpFrame.xy);
			// . S .
			// W M E
			// . N .

			bool earlyExit = max( max( max(
					contrast( rgbaM, rgbaN ),
					contrast( rgbaM, rgbaS ) ),
					contrast( rgbaM, rgbaE ) ),
					contrast( rgbaM, rgbaW ) )
					< fxaaQualityEdgeThreshold;
			// . 0 .
			// 0 0 0
			// . 0 .

			#if (FXAA_DISCARD == 1)
				if(earlyExit) FxaaDiscard;
			#else
				if(earlyExit) return rgbaM;
			#endif

			float contrastN = contrast( rgbaM, rgbaN );
			float contrastS = contrast( rgbaM, rgbaS );
			float contrastE = contrast( rgbaM, rgbaE );
			float contrastW = contrast( rgbaM, rgbaW );

			float relativeVContrast = ( contrastN + contrastS ) - ( contrastE + contrastW );
			relativeVContrast *= fxaaQualityinvEdgeThreshold;

			bool horzSpan = relativeVContrast > 0.;
			// . 1 .
			// 0 0 0
			// . 1 .

			// 45 deg edge detection and corners of objects, aka V/H contrast is too similar
			if( abs( relativeVContrast ) < .3 ) {
				// locate the edge
				vec2 dirToEdge;
				dirToEdge.x = contrastE > contrastW ? 1. : -1.;
				dirToEdge.y = contrastS > contrastN ? 1. : -1.;
				// . 2 .      . 1 .
				// 1 0 2  ~=  0 0 1
				// . 1 .      . 0 .

				// tap 2 pixels and see which ones are "outside" the edge, to
				// determine if the edge is vertical or horizontal

				vec4 rgbaAlongH = FxaaTexOff(tex, posM, vec2( dirToEdge.x, -dirToEdge.y ), fxaaQualityRcpFrame.xy);
				float matchAlongH = contrast( rgbaM, rgbaAlongH );
				// . 1 .
				// 0 0 1
				// . 0 H

				vec4 rgbaAlongV = FxaaTexOff(tex, posM, vec2( -dirToEdge.x, dirToEdge.y ), fxaaQualityRcpFrame.xy);
				float matchAlongV = contrast( rgbaM, rgbaAlongV );
				// V 1 .
				// 0 0 1
				// . 0 .

				relativeVContrast = matchAlongV - matchAlongH;
				relativeVContrast *= fxaaQualityinvEdgeThreshold;

				if( abs( relativeVContrast ) < .3 ) { // 45 deg edge
					// 1 1 .
					// 0 0 1
					// . 0 1

					// do a simple blur
					return mix(
						rgbaM,
						(rgbaN + rgbaS + rgbaE + rgbaW) * .25,
						.4
					);
				}

				horzSpan = relativeVContrast > 0.;
			}

			if(!horzSpan) rgbaN = rgbaW;
			if(!horzSpan) rgbaS = rgbaE;
			// . 0 .      1
			// 1 0 1  ->  0
			// . 0 .      1

			bool pairN = contrast( rgbaM, rgbaN ) > contrast( rgbaM, rgbaS );
			if(!pairN) rgbaN = rgbaS;

			vec2 offNP;
			offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
			offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;

			bool doneN = false;
			bool doneP = false;

			float nDist = 0.;
			float pDist = 0.;

			vec2 posN = posM;
			vec2 posP = posM;

			int iterationsUsed = 0;
			int iterationsUsedN = 0;
			int iterationsUsedP = 0;
			for( int i = 0; i < NUM_SAMPLES; i++ ) {
				iterationsUsed = i;

				float increment = float(i + 1);

				if(!doneN) {
					nDist += increment;
					posN = posM + offNP * nDist;
					vec4 rgbaEndN = FxaaTexTop(tex, posN.xy);
					doneN = contrast( rgbaEndN, rgbaM ) > contrast( rgbaEndN, rgbaN );
					iterationsUsedN = i;
				}

				if(!doneP) {
					pDist += increment;
					posP = posM - offNP * pDist;
					vec4 rgbaEndP = FxaaTexTop(tex, posP.xy);
					doneP = contrast( rgbaEndP, rgbaM ) > contrast( rgbaEndP, rgbaN );
					iterationsUsedP = i;
				}

				if(doneN || doneP) break;
			}


			if ( !doneP && !doneN ) return rgbaM; // failed to find end of edge

			float dist = min(
				doneN ? float( iterationsUsedN ) / float( NUM_SAMPLES - 1 ) : 1.,
				doneP ? float( iterationsUsedP ) / float( NUM_SAMPLES - 1 ) : 1.
			);

			// hacky way of reduces blurriness of mostly diagonal edges
			// but reduces AA quality
			dist = pow(dist, .5);

			dist = 1. - dist;

			return mix(
				rgbaM,
				rgbaN,
				dist * .5
			);
		}

		void main() {
			const float edgeDetectionQuality = .2;
			const float invEdgeDetectionQuality = 1. / edgeDetectionQuality;

			gl_FragColor = FxaaPixelShader(
				vUv,
				tDiffuse,
				resolution,
				edgeDetectionQuality, // [0,1] contrast needed, otherwise early discard
				invEdgeDetectionQuality
			);

		}
	`};var Zt=function(){var c=0,e=document.createElement("div");e.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",e.addEventListener("click",function(p){p.preventDefault(),s(++c%e.children.length)},!1);function t(p){return e.appendChild(p.dom),p}function s(p){for(var u=0;u<e.children.length;u++)e.children[u].style.display=u===p?"block":"none";c=p}var n=(performance||Date).now(),r=n,i=0,a=t(new Zt.Panel("FPS","#0ff","#002")),l=t(new Zt.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var h=t(new Zt.Panel("MB","#f08","#201"));return s(0),{REVISION:16,dom:e,addPanel:t,showPanel:s,begin:function(){n=(performance||Date).now()},end:function(){i++;var p=(performance||Date).now();if(l.update(p-n,200),p>=r+1e3&&(a.update(i*1e3/(p-r),100),r=p,i=0,h)){var u=performance.memory;h.update(u.usedJSHeapSize/1048576,u.jsHeapSizeLimit/1048576)}return p},update:function(){n=this.end()},domElement:e,setMode:s}};Zt.Panel=function(c,e,t){var s=1/0,n=0,r=Math.round,i=r(window.devicePixelRatio||1),a=80*i,l=48*i,h=3*i,p=2*i,u=3*i,d=15*i,g=74*i,T=30*i,x=document.createElement("canvas");x.width=a,x.height=l,x.style.cssText="width:80px;height:48px";var v=x.getContext("2d");return v.font="bold "+9*i+"px Helvetica,Arial,sans-serif",v.textBaseline="top",v.fillStyle=t,v.fillRect(0,0,a,l),v.fillStyle=e,v.fillText(c,h,p),v.fillRect(u,d,g,T),v.fillStyle=t,v.globalAlpha=.9,v.fillRect(u,d,g,T),{dom:x,update:function(R,_){s=Math.min(s,R),n=Math.max(n,R),v.fillStyle=t,v.globalAlpha=1,v.fillRect(0,0,a,d),v.fillStyle=e,v.fillText(r(R)+" "+c+" ("+r(s)+"-"+r(n)+")",h,p),v.drawImage(x,u+i,d,g-i,T,u,d,g-i,T),v.fillRect(u+g-i,d,i,T),v.fillStyle=t,v.globalAlpha=.9,v.fillRect(u+g-i,d,i,r((1-R/_)*T))}}};const gt=new ys,Re=new L,ct=new L,me=new ve,Kn={X:new L(1,0,0),Y:new L(0,1,0),Z:new L(0,0,1)},vn={type:"change"},qn={type:"mouseDown",mode:null},$n={type:"mouseUp",mode:null},Jn={type:"objectChange"};class bo extends ht{constructor(e,t){super(),t===void 0&&(console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'),t=document),this.isTransformControls=!0,this.visible=!1,this.domElement=t,this.domElement.style.touchAction="none";const s=new Lo;this._gizmo=s,this.add(s);const n=new Do;this._plane=n,this.add(n);const r=this;function i(_,I){let O=I;Object.defineProperty(r,_,{get:function(){return O!==void 0?O:I},set:function(H){O!==H&&(O=H,n[_]=H,s[_]=H,r.dispatchEvent({type:_+"-changed",value:H}),r.dispatchEvent(vn))}}),r[_]=I,n[_]=I,s[_]=I}i("camera",e),i("object",void 0),i("enabled",!0),i("axis",null),i("mode","translate"),i("translationSnap",null),i("rotationSnap",null),i("scaleSnap",null),i("space","world"),i("size",1),i("dragging",!1),i("showX",!0),i("showY",!0),i("showZ",!0);const a=new L,l=new L,h=new ve,p=new ve,u=new L,d=new ve,g=new L,T=new L,x=new L,v=0,R=new L;i("worldPosition",a),i("worldPositionStart",l),i("worldQuaternion",h),i("worldQuaternionStart",p),i("cameraPosition",u),i("cameraQuaternion",d),i("pointStart",g),i("pointEnd",T),i("rotationAxis",x),i("rotationAngle",v),i("eye",R),this._offset=new L,this._startNorm=new L,this._endNorm=new L,this._cameraScale=new L,this._parentPosition=new L,this._parentQuaternion=new ve,this._parentQuaternionInv=new ve,this._parentScale=new L,this._worldScaleStart=new L,this._worldQuaternionInv=new ve,this._worldScale=new L,this._positionStart=new L,this._quaternionStart=new ve,this._scaleStart=new L,this._getPointer=Ro.bind(this),this._onPointerDown=_o.bind(this),this._onPointerHover=Io.bind(this),this._onPointerMove=Co.bind(this),this._onPointerUp=Po.bind(this),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointermove",this._onPointerHover),this.domElement.addEventListener("pointerup",this._onPointerUp)}updateMatrixWorld(e){this.object!==void 0&&(this.object.updateMatrixWorld(),this.object.parent===null?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(this._parentPosition,this._parentQuaternion,this._parentScale),this.object.matrixWorld.decompose(this.worldPosition,this.worldQuaternion,this._worldScale),this._parentQuaternionInv.copy(this._parentQuaternion).invert(),this._worldQuaternionInv.copy(this.worldQuaternion).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(this.cameraPosition,this.cameraQuaternion,this._cameraScale),this.camera.isOrthographicCamera?this.camera.getWorldDirection(this.eye).negate():this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),super.updateMatrixWorld(e)}pointerHover(e){if(this.object===void 0||this.dragging===!0)return;e!==null&&gt.setFromCamera(e,this.camera);const t=xn(this._gizmo.picker[this.mode],gt);t?this.axis=t.object.name:this.axis=null}pointerDown(e){if(!(this.object===void 0||this.dragging===!0||e!=null&&e.button!==0)&&this.axis!==null){e!==null&&gt.setFromCamera(e,this.camera);const t=xn(this._plane,gt,!0);t&&(this.object.updateMatrixWorld(),this.object.parent.updateMatrixWorld(),this._positionStart.copy(this.object.position),this._quaternionStart.copy(this.object.quaternion),this._scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this._worldScaleStart),this.pointStart.copy(t.point).sub(this.worldPositionStart)),this.dragging=!0,qn.mode=this.mode,this.dispatchEvent(qn)}}pointerMove(e){const t=this.axis,s=this.mode,n=this.object;let r=this.space;if(s==="scale"?r="local":(t==="E"||t==="XYZE"||t==="XYZ")&&(r="world"),n===void 0||t===null||this.dragging===!1||e!==null&&e.button!==-1)return;e!==null&&gt.setFromCamera(e,this.camera);const i=xn(this._plane,gt,!0);if(i){if(this.pointEnd.copy(i.point).sub(this.worldPositionStart),s==="translate")this._offset.copy(this.pointEnd).sub(this.pointStart),r==="local"&&t!=="XYZ"&&this._offset.applyQuaternion(this._worldQuaternionInv),t.indexOf("X")===-1&&(this._offset.x=0),t.indexOf("Y")===-1&&(this._offset.y=0),t.indexOf("Z")===-1&&(this._offset.z=0),r==="local"&&t!=="XYZ"?this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale):this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale),n.position.copy(this._offset).add(this._positionStart),this.translationSnap&&(r==="local"&&(n.position.applyQuaternion(me.copy(this._quaternionStart).invert()),t.search("X")!==-1&&(n.position.x=Math.round(n.position.x/this.translationSnap)*this.translationSnap),t.search("Y")!==-1&&(n.position.y=Math.round(n.position.y/this.translationSnap)*this.translationSnap),t.search("Z")!==-1&&(n.position.z=Math.round(n.position.z/this.translationSnap)*this.translationSnap),n.position.applyQuaternion(this._quaternionStart)),r==="world"&&(n.parent&&n.position.add(Re.setFromMatrixPosition(n.parent.matrixWorld)),t.search("X")!==-1&&(n.position.x=Math.round(n.position.x/this.translationSnap)*this.translationSnap),t.search("Y")!==-1&&(n.position.y=Math.round(n.position.y/this.translationSnap)*this.translationSnap),t.search("Z")!==-1&&(n.position.z=Math.round(n.position.z/this.translationSnap)*this.translationSnap),n.parent&&n.position.sub(Re.setFromMatrixPosition(n.parent.matrixWorld))));else if(s==="scale"){if(t.search("XYZ")!==-1){let a=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(a*=-1),ct.set(a,a,a)}else Re.copy(this.pointStart),ct.copy(this.pointEnd),Re.applyQuaternion(this._worldQuaternionInv),ct.applyQuaternion(this._worldQuaternionInv),ct.divide(Re),t.search("X")===-1&&(ct.x=1),t.search("Y")===-1&&(ct.y=1),t.search("Z")===-1&&(ct.z=1);n.scale.copy(this._scaleStart).multiply(ct),this.scaleSnap&&(t.search("X")!==-1&&(n.scale.x=Math.round(n.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),t.search("Y")!==-1&&(n.scale.y=Math.round(n.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),t.search("Z")!==-1&&(n.scale.z=Math.round(n.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if(s==="rotate"){this._offset.copy(this.pointEnd).sub(this.pointStart);const a=20/this.worldPosition.distanceTo(Re.setFromMatrixPosition(this.camera.matrixWorld));let l=!1;t==="XYZE"?(this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),this.rotationAngle=this._offset.dot(Re.copy(this.rotationAxis).cross(this.eye))*a):(t==="X"||t==="Y"||t==="Z")&&(this.rotationAxis.copy(Kn[t]),Re.copy(Kn[t]),r==="local"&&Re.applyQuaternion(this.worldQuaternion),Re.cross(this.eye),Re.length()===0?l=!0:this.rotationAngle=this._offset.dot(Re.normalize())*a),(t==="E"||l)&&(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this._startNorm.copy(this.pointStart).normalize(),this._endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this._endNorm.cross(this._startNorm).dot(this.eye)<0?1:-1),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),r==="local"&&t!=="E"&&t!=="XYZE"?(n.quaternion.copy(this._quaternionStart),n.quaternion.multiply(me.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this._parentQuaternionInv),n.quaternion.copy(me.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),n.quaternion.multiply(this._quaternionStart).normalize())}this.dispatchEvent(vn),this.dispatchEvent(Jn)}}pointerUp(e){e!==null&&e.button!==0||(this.dragging&&this.axis!==null&&($n.mode=this.mode,this.dispatchEvent($n)),this.dragging=!1,this.axis=null)}dispose(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerHover),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.traverse(function(e){e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()})}attach(e){return this.object=e,this.visible=!0,this}detach(){return this.object=void 0,this.visible=!1,this.axis=null,this}reset(){this.enabled&&this.dragging&&(this.object.position.copy(this._positionStart),this.object.quaternion.copy(this._quaternionStart),this.object.scale.copy(this._scaleStart),this.dispatchEvent(vn),this.dispatchEvent(Jn),this.pointStart.copy(this.pointEnd))}getRaycaster(){return gt}getMode(){return this.mode}setMode(e){this.mode=e}setTranslationSnap(e){this.translationSnap=e}setRotationSnap(e){this.rotationSnap=e}setScaleSnap(e){this.scaleSnap=e}setSize(e){this.size=e}setSpace(e){this.space=e}}function Ro(c){if(this.domElement.ownerDocument.pointerLockElement)return{x:0,y:0,button:c.button};{const e=this.domElement.getBoundingClientRect();return{x:(c.clientX-e.left)/e.width*2-1,y:-(c.clientY-e.top)/e.height*2+1,button:c.button}}}function Io(c){if(this.enabled)switch(c.pointerType){case"mouse":case"pen":this.pointerHover(this._getPointer(c));break}}function _o(c){this.enabled&&(document.pointerLockElement||this.domElement.setPointerCapture(c.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.pointerHover(this._getPointer(c)),this.pointerDown(this._getPointer(c)))}function Co(c){this.enabled&&this.pointerMove(this._getPointer(c))}function Po(c){this.enabled&&(this.domElement.releasePointerCapture(c.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.pointerUp(this._getPointer(c)))}function xn(c,e,t){const s=e.intersectObject(c,!0);for(let n=0;n<s.length;n++)if(s[n].object.visible||t)return s[n];return!1}const tn=new We,ce=new L(0,1,0),es=new L(0,0,0),ts=new oe,nn=new ve,rn=new ve,$e=new L,ns=new oe,Ht=new L(1,0,0),wt=new L(0,1,0),Gt=new L(0,0,1),sn=new L,kt=new L,Bt=new L;class Lo extends ht{constructor(){super(),this.isTransformControlsGizmo=!0,this.type="TransformControlsGizmo";const e=new Ve({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),t=new Yt({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),s=e.clone();s.opacity=.15;const n=t.clone();n.opacity=.5;const r=e.clone();r.color.setHex(16711680);const i=e.clone();i.color.setHex(65280);const a=e.clone();a.color.setHex(255);const l=e.clone();l.color.setHex(16711680),l.opacity=.5;const h=e.clone();h.color.setHex(65280),h.opacity=.5;const p=e.clone();p.color.setHex(255),p.opacity=.5;const u=e.clone();u.opacity=.25;const d=e.clone();d.color.setHex(16776960),d.opacity=.25,e.clone().color.setHex(16776960);const T=e.clone();T.color.setHex(7895160);const x=new Pe(0,.04,.1,12);x.translate(0,.05,0);const v=new Ee(.08,.08,.08);v.translate(0,.04,0);const R=new Ze;R.setAttribute("position",new Oe([0,0,0,1,0,0],3));const _=new Pe(.0075,.0075,.5,3);_.translate(0,.25,0);function I(J,K){const ue=new Ot(J,.0075,3,64,K*Math.PI*2);return ue.rotateY(Math.PI/2),ue.rotateX(Math.PI/2),ue}function O(){const J=new Ze;return J.setAttribute("position",new Oe([0,0,0,1,1,1],3)),J}const H={X:[[new F(x,r),[.5,0,0],[0,0,-Math.PI/2]],[new F(x,r),[-.5,0,0],[0,0,Math.PI/2]],[new F(_,r),[0,0,0],[0,0,-Math.PI/2]]],Y:[[new F(x,i),[0,.5,0]],[new F(x,i),[0,-.5,0],[Math.PI,0,0]],[new F(_,i)]],Z:[[new F(x,a),[0,0,.5],[Math.PI/2,0,0]],[new F(x,a),[0,0,-.5],[-Math.PI/2,0,0]],[new F(_,a),null,[Math.PI/2,0,0]]],XYZ:[[new F(new Jt(.1,0),u.clone()),[0,0,0]]],XY:[[new F(new Ee(.15,.15,.01),p.clone()),[.15,.15,0]]],YZ:[[new F(new Ee(.15,.15,.01),l.clone()),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new F(new Ee(.15,.15,.01),h.clone()),[.15,0,.15],[-Math.PI/2,0,0]]]},j={X:[[new F(new Pe(.2,0,.6,4),s),[.3,0,0],[0,0,-Math.PI/2]],[new F(new Pe(.2,0,.6,4),s),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new F(new Pe(.2,0,.6,4),s),[0,.3,0]],[new F(new Pe(.2,0,.6,4),s),[0,-.3,0],[0,0,Math.PI]]],Z:[[new F(new Pe(.2,0,.6,4),s),[0,0,.3],[Math.PI/2,0,0]],[new F(new Pe(.2,0,.6,4),s),[0,0,-.3],[-Math.PI/2,0,0]]],XYZ:[[new F(new Jt(.2,0),s)]],XY:[[new F(new Ee(.2,.2,.01),s),[.15,.15,0]]],YZ:[[new F(new Ee(.2,.2,.01),s),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new F(new Ee(.2,.2,.01),s),[.15,0,.15],[-Math.PI/2,0,0]]]},W={START:[[new F(new Jt(.01,2),n),null,null,null,"helper"]],END:[[new F(new Jt(.01,2),n),null,null,null,"helper"]],DELTA:[[new ze(O(),n),null,null,null,"helper"]],X:[[new ze(R,n.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new ze(R,n.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new ze(R,n.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},C={XYZE:[[new F(I(.5,1),T),null,[0,Math.PI/2,0]]],X:[[new F(I(.5,.5),r)]],Y:[[new F(I(.5,.5),i),null,[0,0,-Math.PI/2]]],Z:[[new F(I(.5,.5),a),null,[0,Math.PI/2,0]]],E:[[new F(I(.75,1),d),null,[0,Math.PI/2,0]]]},z={AXIS:[[new ze(R,n.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},X={XYZE:[[new F(new Gr(.25,10,8),s)]],X:[[new F(new Ot(.5,.1,4,24),s),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new F(new Ot(.5,.1,4,24),s),[0,0,0],[Math.PI/2,0,0]]],Z:[[new F(new Ot(.5,.1,4,24),s),[0,0,0],[0,0,-Math.PI/2]]],E:[[new F(new Ot(.75,.1,2,24),s)]]},Y={X:[[new F(v,r),[.5,0,0],[0,0,-Math.PI/2]],[new F(_,r),[0,0,0],[0,0,-Math.PI/2]],[new F(v,r),[-.5,0,0],[0,0,Math.PI/2]]],Y:[[new F(v,i),[0,.5,0]],[new F(_,i)],[new F(v,i),[0,-.5,0],[0,0,Math.PI]]],Z:[[new F(v,a),[0,0,.5],[Math.PI/2,0,0]],[new F(_,a),[0,0,0],[Math.PI/2,0,0]],[new F(v,a),[0,0,-.5],[-Math.PI/2,0,0]]],XY:[[new F(new Ee(.15,.15,.01),p),[.15,.15,0]]],YZ:[[new F(new Ee(.15,.15,.01),l),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new F(new Ee(.15,.15,.01),h),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new F(new Ee(.1,.1,.1),u.clone())]]},$={X:[[new F(new Pe(.2,0,.6,4),s),[.3,0,0],[0,0,-Math.PI/2]],[new F(new Pe(.2,0,.6,4),s),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new F(new Pe(.2,0,.6,4),s),[0,.3,0]],[new F(new Pe(.2,0,.6,4),s),[0,-.3,0],[0,0,Math.PI]]],Z:[[new F(new Pe(.2,0,.6,4),s),[0,0,.3],[Math.PI/2,0,0]],[new F(new Pe(.2,0,.6,4),s),[0,0,-.3],[-Math.PI/2,0,0]]],XY:[[new F(new Ee(.2,.2,.01),s),[.15,.15,0]]],YZ:[[new F(new Ee(.2,.2,.01),s),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new F(new Ee(.2,.2,.01),s),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new F(new Ee(.2,.2,.2),s),[0,0,0]]]},ae={X:[[new ze(R,n.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new ze(R,n.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new ze(R,n.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]};function Z(J){const K=new ht;for(const ue in J)for(let Ie=J[ue].length;Ie--;){const ne=J[ue][Ie][0].clone(),pe=J[ue][Ie][1],Ne=J[ue][Ie][2],le=J[ue][Ie][3],ye=J[ue][Ie][4];ne.name=ue,ne.tag=ye,pe&&ne.position.set(pe[0],pe[1],pe[2]),Ne&&ne.rotation.set(Ne[0],Ne[1],Ne[2]),le&&ne.scale.set(le[0],le[1],le[2]),ne.updateMatrix();const ke=ne.geometry.clone();ke.applyMatrix4(ne.matrix),ne.geometry=ke,ne.renderOrder=1/0,ne.position.set(0,0,0),ne.rotation.set(0,0,0),ne.scale.set(1,1,1),K.add(ne)}return K}this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=Z(H)),this.add(this.gizmo.rotate=Z(C)),this.add(this.gizmo.scale=Z(Y)),this.add(this.picker.translate=Z(j)),this.add(this.picker.rotate=Z(X)),this.add(this.picker.scale=Z($)),this.add(this.helper.translate=Z(W)),this.add(this.helper.rotate=Z(z)),this.add(this.helper.scale=Z(ae)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}updateMatrixWorld(e){const s=(this.mode==="scale"?"local":this.space)==="local"?this.worldQuaternion:rn;this.gizmo.translate.visible=this.mode==="translate",this.gizmo.rotate.visible=this.mode==="rotate",this.gizmo.scale.visible=this.mode==="scale",this.helper.translate.visible=this.mode==="translate",this.helper.rotate.visible=this.mode==="rotate",this.helper.scale.visible=this.mode==="scale";let n=[];n=n.concat(this.picker[this.mode].children),n=n.concat(this.gizmo[this.mode].children),n=n.concat(this.helper[this.mode].children);for(let r=0;r<n.length;r++){const i=n[r];i.visible=!0,i.rotation.set(0,0,0),i.position.copy(this.worldPosition);let a;if(this.camera.isOrthographicCamera?a=(this.camera.top-this.camera.bottom)/this.camera.zoom:a=this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),i.scale.set(1,1,1).multiplyScalar(a*this.size/4),i.tag==="helper"){i.visible=!1,i.name==="AXIS"?(i.visible=!!this.axis,this.axis==="X"&&(me.setFromEuler(tn.set(0,0,0)),i.quaternion.copy(s).multiply(me),Math.abs(ce.copy(Ht).applyQuaternion(s).dot(this.eye))>.9&&(i.visible=!1)),this.axis==="Y"&&(me.setFromEuler(tn.set(0,0,Math.PI/2)),i.quaternion.copy(s).multiply(me),Math.abs(ce.copy(wt).applyQuaternion(s).dot(this.eye))>.9&&(i.visible=!1)),this.axis==="Z"&&(me.setFromEuler(tn.set(0,Math.PI/2,0)),i.quaternion.copy(s).multiply(me),Math.abs(ce.copy(Gt).applyQuaternion(s).dot(this.eye))>.9&&(i.visible=!1)),this.axis==="XYZE"&&(me.setFromEuler(tn.set(0,Math.PI/2,0)),ce.copy(this.rotationAxis),i.quaternion.setFromRotationMatrix(ts.lookAt(es,ce,wt)),i.quaternion.multiply(me),i.visible=this.dragging),this.axis==="E"&&(i.visible=!1)):i.name==="START"?(i.position.copy(this.worldPositionStart),i.visible=this.dragging):i.name==="END"?(i.position.copy(this.worldPosition),i.visible=this.dragging):i.name==="DELTA"?(i.position.copy(this.worldPositionStart),i.quaternion.copy(this.worldQuaternionStart),Re.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),Re.applyQuaternion(this.worldQuaternionStart.clone().invert()),i.scale.copy(Re),i.visible=this.dragging):(i.quaternion.copy(s),this.dragging?i.position.copy(this.worldPositionStart):i.position.copy(this.worldPosition),this.axis&&(i.visible=this.axis.search(i.name)!==-1));continue}i.quaternion.copy(s),this.mode==="translate"||this.mode==="scale"?(i.name==="X"&&Math.abs(ce.copy(Ht).applyQuaternion(s).dot(this.eye))>.99&&(i.scale.set(1e-10,1e-10,1e-10),i.visible=!1),i.name==="Y"&&Math.abs(ce.copy(wt).applyQuaternion(s).dot(this.eye))>.99&&(i.scale.set(1e-10,1e-10,1e-10),i.visible=!1),i.name==="Z"&&Math.abs(ce.copy(Gt).applyQuaternion(s).dot(this.eye))>.99&&(i.scale.set(1e-10,1e-10,1e-10),i.visible=!1),i.name==="XY"&&Math.abs(ce.copy(Gt).applyQuaternion(s).dot(this.eye))<.2&&(i.scale.set(1e-10,1e-10,1e-10),i.visible=!1),i.name==="YZ"&&Math.abs(ce.copy(Ht).applyQuaternion(s).dot(this.eye))<.2&&(i.scale.set(1e-10,1e-10,1e-10),i.visible=!1),i.name==="XZ"&&Math.abs(ce.copy(wt).applyQuaternion(s).dot(this.eye))<.2&&(i.scale.set(1e-10,1e-10,1e-10),i.visible=!1)):this.mode==="rotate"&&(nn.copy(s),ce.copy(this.eye).applyQuaternion(me.copy(s).invert()),i.name.search("E")!==-1&&i.quaternion.setFromRotationMatrix(ts.lookAt(this.eye,es,wt)),i.name==="X"&&(me.setFromAxisAngle(Ht,Math.atan2(-ce.y,ce.z)),me.multiplyQuaternions(nn,me),i.quaternion.copy(me)),i.name==="Y"&&(me.setFromAxisAngle(wt,Math.atan2(ce.x,ce.z)),me.multiplyQuaternions(nn,me),i.quaternion.copy(me)),i.name==="Z"&&(me.setFromAxisAngle(Gt,Math.atan2(ce.y,ce.x)),me.multiplyQuaternions(nn,me),i.quaternion.copy(me))),i.visible=i.visible&&(i.name.indexOf("X")===-1||this.showX),i.visible=i.visible&&(i.name.indexOf("Y")===-1||this.showY),i.visible=i.visible&&(i.name.indexOf("Z")===-1||this.showZ),i.visible=i.visible&&(i.name.indexOf("E")===-1||this.showX&&this.showY&&this.showZ),i.material._color=i.material._color||i.material.color.clone(),i.material._opacity=i.material._opacity||i.material.opacity,i.material.color.copy(i.material._color),i.material.opacity=i.material._opacity,this.enabled&&this.axis&&(i.name===this.axis||this.axis.split("").some(function(l){return i.name===l}))&&(i.material.color.setHex(16776960),i.material.opacity=1)}super.updateMatrixWorld(e)}}class Do extends F{constructor(){super(new zr(1e5,1e5,2,2),new Ve({visible:!1,wireframe:!0,side:rt,transparent:!0,opacity:.1,toneMapped:!1})),this.isTransformControlsPlane=!0,this.type="TransformControlsPlane"}updateMatrixWorld(e){let t=this.space;switch(this.position.copy(this.worldPosition),this.mode==="scale"&&(t="local"),sn.copy(Ht).applyQuaternion(t==="local"?this.worldQuaternion:rn),kt.copy(wt).applyQuaternion(t==="local"?this.worldQuaternion:rn),Bt.copy(Gt).applyQuaternion(t==="local"?this.worldQuaternion:rn),ce.copy(kt),this.mode){case"translate":case"scale":switch(this.axis){case"X":ce.copy(this.eye).cross(sn),$e.copy(sn).cross(ce);break;case"Y":ce.copy(this.eye).cross(kt),$e.copy(kt).cross(ce);break;case"Z":ce.copy(this.eye).cross(Bt),$e.copy(Bt).cross(ce);break;case"XY":$e.copy(Bt);break;case"YZ":$e.copy(sn);break;case"XZ":ce.copy(Bt),$e.copy(kt);break;case"XYZ":case"E":$e.set(0,0,0);break}break;case"rotate":default:$e.set(0,0,0)}$e.length()===0?this.quaternion.copy(this.cameraQuaternion):(ns.lookAt(Re.set(0,0,0),$e,ce),this.quaternion.setFromRotationMatrix(ns)),super.updateMatrixWorld(e)}}class Fo extends Ts{constructor(e){super(e),this.type=Le}parse(e){const i=function(C,z){switch(C){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(z||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(z||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(z||""));default:case 4:throw new Error("THREE.RGBELoader: Memory Error: "+(z||""))}},p=`
`,u=function(C,z,X){z=z||1024;let $=C.pos,ae=-1,Z=0,J="",K=String.fromCharCode.apply(null,new Uint16Array(C.subarray($,$+128)));for(;0>(ae=K.indexOf(p))&&Z<z&&$<C.byteLength;)J+=K,Z+=K.length,$+=128,K+=String.fromCharCode.apply(null,new Uint16Array(C.subarray($,$+128)));return-1<ae?(C.pos+=Z+ae+1,J+K.slice(0,ae)):!1},d=function(C){const z=/^#\?(\S+)/,X=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,Y=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,$=/^\s*FORMAT=(\S+)\s*$/,ae=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,Z={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let J,K;for((C.pos>=C.byteLength||!(J=u(C)))&&i(1,"no header found"),(K=J.match(z))||i(3,"bad initial token"),Z.valid|=1,Z.programtype=K[1],Z.string+=J+`
`;J=u(C),J!==!1;){if(Z.string+=J+`
`,J.charAt(0)==="#"){Z.comments+=J+`
`;continue}if((K=J.match(X))&&(Z.gamma=parseFloat(K[1])),(K=J.match(Y))&&(Z.exposure=parseFloat(K[1])),(K=J.match($))&&(Z.valid|=2,Z.format=K[1]),(K=J.match(ae))&&(Z.valid|=4,Z.height=parseInt(K[1],10),Z.width=parseInt(K[2],10)),Z.valid&2&&Z.valid&4)break}return Z.valid&2||i(3,"missing format specifier"),Z.valid&4||i(3,"missing image size specifier"),Z},g=function(C,z,X){const Y=z;if(Y<8||Y>32767||C[0]!==2||C[1]!==2||C[2]&128)return new Uint8Array(C);Y!==(C[2]<<8|C[3])&&i(3,"wrong scanline width");const $=new Uint8Array(4*z*X);$.length||i(4,"unable to allocate buffer space");let ae=0,Z=0;const J=4*Y,K=new Uint8Array(4),ue=new Uint8Array(J);let Ie=X;for(;Ie>0&&Z<C.byteLength;){Z+4>C.byteLength&&i(1),K[0]=C[Z++],K[1]=C[Z++],K[2]=C[Z++],K[3]=C[Z++],(K[0]!=2||K[1]!=2||(K[2]<<8|K[3])!=Y)&&i(3,"bad rgbe scanline format");let ne=0,pe;for(;ne<J&&Z<C.byteLength;){pe=C[Z++];const le=pe>128;if(le&&(pe-=128),(pe===0||ne+pe>J)&&i(3,"bad scanline data"),le){const ye=C[Z++];for(let ke=0;ke<pe;ke++)ue[ne++]=ye}else ue.set(C.subarray(Z,Z+pe),ne),ne+=pe,Z+=pe}const Ne=Y;for(let le=0;le<Ne;le++){let ye=0;$[ae]=ue[le+ye],ye+=Y,$[ae+1]=ue[le+ye],ye+=Y,$[ae+2]=ue[le+ye],ye+=Y,$[ae+3]=ue[le+ye],ae+=4}Ie--}return $},T=function(C,z,X,Y){const $=C[z+3],ae=Math.pow(2,$-128)/255;X[Y+0]=C[z+0]*ae,X[Y+1]=C[z+1]*ae,X[Y+2]=C[z+2]*ae,X[Y+3]=1},x=function(C,z,X,Y){const $=C[z+3],ae=Math.pow(2,$-128)/255;X[Y+0]=At.toHalfFloat(Math.min(C[z+0]*ae,65504)),X[Y+1]=At.toHalfFloat(Math.min(C[z+1]*ae,65504)),X[Y+2]=At.toHalfFloat(Math.min(C[z+2]*ae,65504)),X[Y+3]=At.toHalfFloat(1)},v=new Uint8Array(e);v.pos=0;const R=d(v),_=R.width,I=R.height,O=g(v.subarray(v.pos),_,I);let H,j,W;switch(this.type){case bt:W=O.length/4;const C=new Float32Array(W*4);for(let X=0;X<W;X++)T(O,X*4,C,X*4);H=C,j=bt;break;case Le:W=O.length/4;const z=new Uint16Array(W*4);for(let X=0;X<W;X++)x(O,X*4,z,X*4);H=z,j=Le;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:_,height:I,data:H,header:R.string,gamma:R.gamma,exposure:R.exposure,type:j}}setDataType(e){return this.type=e,this}load(e,t,s,n){function r(i,a){switch(i.type){case bt:case Le:i.colorSpace=je,i.minFilter=It,i.magFilter=It,i.generateMipmaps=!1,i.flipY=!0;break}t&&t(i,a)}return super.load(e,r,s,n)}}class Oo extends Ts{constructor(e){super(e),this.type=Le}parse(e){const z=Math.pow(2.7182818,2.2);function X(o,f){let m=0;for(let A=0;A<65536;++A)(A==0||o[A>>3]&1<<(A&7))&&(f[m++]=A);const w=m-1;for(;m<65536;)f[m++]=0;return w}function Y(o){for(let f=0;f<16384;f++)o[f]={},o[f].len=0,o[f].lit=0,o[f].p=null}const $={l:0,c:0,lc:0};function ae(o,f,m,w,A){for(;m<o;)f=f<<8|Nn(w,A),m+=8;m-=o,$.l=f>>m&(1<<o)-1,$.c=f,$.lc=m}const Z=new Array(59);function J(o){for(let m=0;m<=58;++m)Z[m]=0;for(let m=0;m<65537;++m)Z[o[m]]+=1;let f=0;for(let m=58;m>0;--m){const w=f+Z[m]>>1;Z[m]=f,f=w}for(let m=0;m<65537;++m){const w=o[m];w>0&&(o[m]=w|Z[w]++<<6)}}function K(o,f,m,w,A,y){const M=f;let P=0,b=0;for(;w<=A;w++){if(M.value-f.value>m)return!1;ae(6,P,b,o,M);const S=$.l;if(P=$.c,b=$.lc,y[w]=S,S==63){if(M.value-f.value>m)throw new Error("Something wrong with hufUnpackEncTable");ae(8,P,b,o,M);let E=$.l+6;if(P=$.c,b=$.lc,w+E>A+1)throw new Error("Something wrong with hufUnpackEncTable");for(;E--;)y[w++]=0;w--}else if(S>=59){let E=S-59+2;if(w+E>A+1)throw new Error("Something wrong with hufUnpackEncTable");for(;E--;)y[w++]=0;w--}}J(y)}function ue(o){return o&63}function Ie(o){return o>>6}function ne(o,f,m,w){for(;f<=m;f++){const A=Ie(o[f]),y=ue(o[f]);if(A>>y)throw new Error("Invalid table entry");if(y>14){const M=w[A>>y-14];if(M.len)throw new Error("Invalid table entry");if(M.lit++,M.p){const P=M.p;M.p=new Array(M.lit);for(let b=0;b<M.lit-1;++b)M.p[b]=P[b]}else M.p=new Array(1);M.p[M.lit-1]=f}else if(y){let M=0;for(let P=1<<14-y;P>0;P--){const b=w[(A<<14-y)+M];if(b.len||b.p)throw new Error("Invalid table entry");b.len=y,b.lit=f,M++}}}return!0}const pe={c:0,lc:0};function Ne(o,f,m,w){o=o<<8|Nn(m,w),f+=8,pe.c=o,pe.lc=f}const le={c:0,lc:0};function ye(o,f,m,w,A,y,M,P,b){if(o==f){w<8&&(Ne(m,w,A,y),m=pe.c,w=pe.lc),w-=8;let S=m>>w;if(S=new Uint8Array([S])[0],P.value+S>b)return!1;const E=M[P.value-1];for(;S-- >0;)M[P.value++]=E}else if(P.value<b)M[P.value++]=o;else return!1;le.c=m,le.lc=w}function ke(o){return o&65535}function it(o){const f=ke(o);return f>32767?f-65536:f}const re={a:0,b:0};function Ke(o,f){const m=it(o),A=it(f),y=m+(A&1)+(A>>1),M=y,P=y-A;re.a=M,re.b=P}function et(o,f){const m=ke(o),w=ke(f),A=m-(w>>1)&65535,y=w+A-32768&65535;re.a=y,re.b=A}function Wt(o,f,m,w,A,y,M){const P=M<16384,b=m>A?A:m;let S=1,E,D;for(;S<=b;)S<<=1;for(S>>=1,E=S,S>>=1;S>=1;){D=0;const U=D+y*(A-E),N=y*S,V=y*E,k=w*S,G=w*E;let Q,ie,ge,Fe;for(;D<=U;D+=V){let fe=D;const te=D+w*(m-E);for(;fe<=te;fe+=G){const xe=fe+k,He=fe+N,Ae=He+k;P?(Ke(o[fe+f],o[He+f]),Q=re.a,ge=re.b,Ke(o[xe+f],o[Ae+f]),ie=re.a,Fe=re.b,Ke(Q,ie),o[fe+f]=re.a,o[xe+f]=re.b,Ke(ge,Fe),o[He+f]=re.a,o[Ae+f]=re.b):(et(o[fe+f],o[He+f]),Q=re.a,ge=re.b,et(o[xe+f],o[Ae+f]),ie=re.a,Fe=re.b,et(Q,ie),o[fe+f]=re.a,o[xe+f]=re.b,et(ge,Fe),o[He+f]=re.a,o[Ae+f]=re.b)}if(m&S){const xe=fe+N;P?Ke(o[fe+f],o[xe+f]):et(o[fe+f],o[xe+f]),Q=re.a,o[xe+f]=re.b,o[fe+f]=Q}}if(A&S){let fe=D;const te=D+w*(m-E);for(;fe<=te;fe+=G){const xe=fe+k;P?Ke(o[fe+f],o[xe+f]):et(o[fe+f],o[xe+f]),Q=re.a,o[xe+f]=re.b,o[fe+f]=Q}}E=S,S>>=1}return D}function cn(o,f,m,w,A,y,M,P,b){let S=0,E=0;const D=M,U=Math.trunc(w.value+(A+7)/8);for(;w.value<U;)for(Ne(S,E,m,w),S=pe.c,E=pe.lc;E>=14;){const V=S>>E-14&16383,k=f[V];if(k.len)E-=k.len,ye(k.lit,y,S,E,m,w,P,b,D),S=le.c,E=le.lc;else{if(!k.p)throw new Error("hufDecode issues");let G;for(G=0;G<k.lit;G++){const Q=ue(o[k.p[G]]);for(;E<Q&&w.value<U;)Ne(S,E,m,w),S=pe.c,E=pe.lc;if(E>=Q&&Ie(o[k.p[G]])==(S>>E-Q&(1<<Q)-1)){E-=Q,ye(k.p[G],y,S,E,m,w,P,b,D),S=le.c,E=le.lc;break}}if(G==k.lit)throw new Error("hufDecode issues")}}const N=8-A&7;for(S>>=N,E-=N;E>0;){const V=f[S<<14-E&16383];if(V.len)E-=V.len,ye(V.lit,y,S,E,m,w,P,b,D),S=le.c,E=le.lc;else throw new Error("hufDecode issues")}return!0}function Ct(o,f,m,w,A,y){const M={value:0},P=m.value,b=Ue(f,m),S=Ue(f,m);m.value+=4;const E=Ue(f,m);if(m.value+=4,b<0||b>=65537||S<0||S>=65537)throw new Error("Something wrong with HUF_ENCSIZE");const D=new Array(65537),U=new Array(16384);Y(U);const N=w-(m.value-P);if(K(o,m,N,b,S,D),E>8*(w-(m.value-P)))throw new Error("Something wrong with hufUncompress");ne(D,b,S,U),cn(D,U,o,m,E,S,y,A,M)}function Kt(o,f,m){for(let w=0;w<m;++w)f[w]=o[f[w]]}function Pt(o){for(let f=1;f<o.length;f++){const m=o[f-1]+o[f]-128;o[f]=m}}function Dn(o,f){let m=0,w=Math.floor((o.length+1)/2),A=0;const y=o.length-1;for(;!(A>y||(f[A++]=o[m++],A>y));)f[A++]=o[w++]}function Fn(o){let f=o.byteLength;const m=new Array;let w=0;const A=new DataView(o);for(;f>0;){const y=A.getInt8(w++);if(y<0){const M=-y;f-=M+1;for(let P=0;P<M;P++)m.push(A.getUint8(w++))}else{const M=y;f-=2;const P=A.getUint8(w++);for(let b=0;b<M+1;b++)m.push(P)}}return m}function Ns(o,f,m,w,A,y){let M=new DataView(y.buffer);const P=m[o.idx[0]].width,b=m[o.idx[0]].height,S=3,E=Math.floor(P/8),D=Math.ceil(P/8),U=Math.ceil(b/8),N=P-(D-1)*8,V=b-(U-1)*8,k={value:0},G=new Array(S),Q=new Array(S),ie=new Array(S),ge=new Array(S),Fe=new Array(S);for(let te=0;te<S;++te)Fe[te]=f[o.idx[te]],G[te]=te<1?0:G[te-1]+D*U,Q[te]=new Float32Array(64),ie[te]=new Uint16Array(64),ge[te]=new Uint16Array(D*64);for(let te=0;te<U;++te){let xe=8;te==U-1&&(xe=V);let He=8;for(let se=0;se<D;++se){se==D-1&&(He=N);for(let he=0;he<S;++he)ie[he].fill(0),ie[he][0]=A[G[he]++],ks(k,w,ie[he]),Bs(ie[he],Q[he]),Us(Q[he]);Hs(Q);for(let he=0;he<S;++he)Gs(Q[he],ge[he],se*64)}let Ae=0;for(let se=0;se<S;++se){const he=m[o.idx[se]].type;for(let tt=8*te;tt<8*te+xe;++tt){Ae=Fe[se][tt];for(let Dt=0;Dt<E;++Dt){const qe=Dt*64+(tt&7)*8;M.setUint16(Ae+0*2*he,ge[se][qe+0],!0),M.setUint16(Ae+1*2*he,ge[se][qe+1],!0),M.setUint16(Ae+2*2*he,ge[se][qe+2],!0),M.setUint16(Ae+3*2*he,ge[se][qe+3],!0),M.setUint16(Ae+4*2*he,ge[se][qe+4],!0),M.setUint16(Ae+5*2*he,ge[se][qe+5],!0),M.setUint16(Ae+6*2*he,ge[se][qe+6],!0),M.setUint16(Ae+7*2*he,ge[se][qe+7],!0),Ae+=8*2*he}}if(E!=D)for(let tt=8*te;tt<8*te+xe;++tt){const Dt=Fe[se][tt]+8*E*2*he,qe=E*64+(tt&7)*8;for(let $t=0;$t<He;++$t)M.setUint16(Dt+$t*2*he,ge[se][qe+$t],!0)}}}const fe=new Uint16Array(P);M=new DataView(y.buffer);for(let te=0;te<S;++te){m[o.idx[te]].decoded=!0;const xe=m[o.idx[te]].type;if(m[te].type==2)for(let He=0;He<b;++He){const Ae=Fe[te][He];for(let se=0;se<P;++se)fe[se]=M.getUint16(Ae+se*2*xe,!0);for(let se=0;se<P;++se)M.setFloat32(Ae+se*2*xe,B(fe[se]),!0)}}}function ks(o,f,m){let w,A=1;for(;A<64;)w=f[o.value],w==65280?A=64:w>>8==255?A+=w&255:(m[A]=w,A++),o.value++}function Bs(o,f){f[0]=B(o[0]),f[1]=B(o[1]),f[2]=B(o[5]),f[3]=B(o[6]),f[4]=B(o[14]),f[5]=B(o[15]),f[6]=B(o[27]),f[7]=B(o[28]),f[8]=B(o[2]),f[9]=B(o[4]),f[10]=B(o[7]),f[11]=B(o[13]),f[12]=B(o[16]),f[13]=B(o[26]),f[14]=B(o[29]),f[15]=B(o[42]),f[16]=B(o[3]),f[17]=B(o[8]),f[18]=B(o[12]),f[19]=B(o[17]),f[20]=B(o[25]),f[21]=B(o[30]),f[22]=B(o[41]),f[23]=B(o[43]),f[24]=B(o[9]),f[25]=B(o[11]),f[26]=B(o[18]),f[27]=B(o[24]),f[28]=B(o[31]),f[29]=B(o[40]),f[30]=B(o[44]),f[31]=B(o[53]),f[32]=B(o[10]),f[33]=B(o[19]),f[34]=B(o[23]),f[35]=B(o[32]),f[36]=B(o[39]),f[37]=B(o[45]),f[38]=B(o[52]),f[39]=B(o[54]),f[40]=B(o[20]),f[41]=B(o[22]),f[42]=B(o[33]),f[43]=B(o[38]),f[44]=B(o[46]),f[45]=B(o[51]),f[46]=B(o[55]),f[47]=B(o[60]),f[48]=B(o[21]),f[49]=B(o[34]),f[50]=B(o[37]),f[51]=B(o[47]),f[52]=B(o[50]),f[53]=B(o[56]),f[54]=B(o[59]),f[55]=B(o[61]),f[56]=B(o[35]),f[57]=B(o[36]),f[58]=B(o[48]),f[59]=B(o[49]),f[60]=B(o[57]),f[61]=B(o[58]),f[62]=B(o[62]),f[63]=B(o[63])}function Us(o){const f=.5*Math.cos(.7853975),m=.5*Math.cos(3.14159/16),w=.5*Math.cos(3.14159/8),A=.5*Math.cos(3*3.14159/16),y=.5*Math.cos(5*3.14159/16),M=.5*Math.cos(3*3.14159/8),P=.5*Math.cos(7*3.14159/16),b=new Array(4),S=new Array(4),E=new Array(4),D=new Array(4);for(let U=0;U<8;++U){const N=U*8;b[0]=w*o[N+2],b[1]=M*o[N+2],b[2]=w*o[N+6],b[3]=M*o[N+6],S[0]=m*o[N+1]+A*o[N+3]+y*o[N+5]+P*o[N+7],S[1]=A*o[N+1]-P*o[N+3]-m*o[N+5]-y*o[N+7],S[2]=y*o[N+1]-m*o[N+3]+P*o[N+5]+A*o[N+7],S[3]=P*o[N+1]-y*o[N+3]+A*o[N+5]-m*o[N+7],E[0]=f*(o[N+0]+o[N+4]),E[3]=f*(o[N+0]-o[N+4]),E[1]=b[0]+b[3],E[2]=b[1]-b[2],D[0]=E[0]+E[1],D[1]=E[3]+E[2],D[2]=E[3]-E[2],D[3]=E[0]-E[1],o[N+0]=D[0]+S[0],o[N+1]=D[1]+S[1],o[N+2]=D[2]+S[2],o[N+3]=D[3]+S[3],o[N+4]=D[3]-S[3],o[N+5]=D[2]-S[2],o[N+6]=D[1]-S[1],o[N+7]=D[0]-S[0]}for(let U=0;U<8;++U)b[0]=w*o[16+U],b[1]=M*o[16+U],b[2]=w*o[48+U],b[3]=M*o[48+U],S[0]=m*o[8+U]+A*o[24+U]+y*o[40+U]+P*o[56+U],S[1]=A*o[8+U]-P*o[24+U]-m*o[40+U]-y*o[56+U],S[2]=y*o[8+U]-m*o[24+U]+P*o[40+U]+A*o[56+U],S[3]=P*o[8+U]-y*o[24+U]+A*o[40+U]-m*o[56+U],E[0]=f*(o[U]+o[32+U]),E[3]=f*(o[U]-o[32+U]),E[1]=b[0]+b[3],E[2]=b[1]-b[2],D[0]=E[0]+E[1],D[1]=E[3]+E[2],D[2]=E[3]-E[2],D[3]=E[0]-E[1],o[0+U]=D[0]+S[0],o[8+U]=D[1]+S[1],o[16+U]=D[2]+S[2],o[24+U]=D[3]+S[3],o[32+U]=D[3]-S[3],o[40+U]=D[2]-S[2],o[48+U]=D[1]-S[1],o[56+U]=D[0]-S[0]}function Hs(o){for(let f=0;f<64;++f){const m=o[0][f],w=o[1][f],A=o[2][f];o[0][f]=m+1.5747*A,o[1][f]=m-.1873*w-.4682*A,o[2][f]=m+1.8556*w}}function Gs(o,f,m){for(let w=0;w<64;++w)f[m+w]=At.toHalfFloat(zs(o[w]))}function zs(o){return o<=1?Math.sign(o)*Math.pow(Math.abs(o),2.2):Math.sign(o)*Math.pow(z,Math.abs(o)-1)}function un(o){return new DataView(o.array.buffer,o.offset.value,o.size)}function Xs(o){const f=o.viewer.buffer.slice(o.offset.value,o.offset.value+o.size),m=new Uint8Array(Fn(f)),w=new Uint8Array(m.length);return Pt(m),Dn(m,w),new DataView(w.buffer)}function hn(o){const f=o.array.slice(o.offset.value,o.offset.value+o.size),m=Ut(f),w=new Uint8Array(m.length);return Pt(m),Dn(m,w),new DataView(w.buffer)}function Vs(o){const f=o.viewer,m={value:o.offset.value},w=new Uint16Array(o.columns*o.lines*(o.inputChannels.length*o.type)),A=new Uint8Array(8192);let y=0;const M=new Array(o.inputChannels.length);for(let V=0,k=o.inputChannels.length;V<k;V++)M[V]={},M[V].start=y,M[V].end=M[V].start,M[V].nx=o.columns,M[V].ny=o.lines,M[V].size=o.type,y+=M[V].nx*M[V].ny*M[V].size;const P=Lt(f,m),b=Lt(f,m);if(b>=8192)throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");if(P<=b)for(let V=0;V<b-P+1;V++)A[V+P]=ot(f,m);const S=new Uint16Array(65536),E=X(A,S),D=Ue(f,m);Ct(o.array,f,m,D,w,y);for(let V=0;V<o.inputChannels.length;++V){const k=M[V];for(let G=0;G<M[V].size;++G)Wt(w,k.start+G,k.nx,k.size,k.ny,k.nx*k.size,E)}Kt(S,w,y);let U=0;const N=new Uint8Array(w.buffer.byteLength);for(let V=0;V<o.lines;V++)for(let k=0;k<o.inputChannels.length;k++){const G=M[k],Q=G.nx*G.size,ie=new Uint8Array(w.buffer,G.end*2,Q*2);N.set(ie,U),U+=Q*2,G.end+=Q}return new DataView(N.buffer)}function Zs(o){const f=o.array.slice(o.offset.value,o.offset.value+o.size),m=Ut(f),w=o.inputChannels.length*o.lines*o.columns*o.totalBytes,A=new ArrayBuffer(w),y=new DataView(A);let M=0,P=0;const b=new Array(4);for(let S=0;S<o.lines;S++)for(let E=0;E<o.inputChannels.length;E++){let D=0;switch(o.inputChannels[E].pixelType){case 1:b[0]=M,b[1]=b[0]+o.columns,M=b[1]+o.columns;for(let N=0;N<o.columns;++N){const V=m[b[0]++]<<8|m[b[1]++];D+=V,y.setUint16(P,D,!0),P+=2}break;case 2:b[0]=M,b[1]=b[0]+o.columns,b[2]=b[1]+o.columns,M=b[2]+o.columns;for(let N=0;N<o.columns;++N){const V=m[b[0]++]<<24|m[b[1]++]<<16|m[b[2]++]<<8;D+=V,y.setUint32(P,D,!0),P+=4}break}}return y}function On(o){const f=o.viewer,m={value:o.offset.value},w=new Uint8Array(o.columns*o.lines*(o.inputChannels.length*o.type*2)),A={version:De(f,m),unknownUncompressedSize:De(f,m),unknownCompressedSize:De(f,m),acCompressedSize:De(f,m),dcCompressedSize:De(f,m),rleCompressedSize:De(f,m),rleUncompressedSize:De(f,m),rleRawSize:De(f,m),totalAcUncompressedCount:De(f,m),totalDcUncompressedCount:De(f,m),acCompression:De(f,m)};if(A.version<2)throw new Error("EXRLoader.parse: "+ft.compression+" version "+A.version+" is unsupported");const y=new Array;let M=Lt(f,m)-2;for(;M>0;){const k=qt(f.buffer,m),G=ot(f,m),Q=G>>2&3,ie=(G>>4)-1,ge=new Int8Array([ie])[0],Fe=ot(f,m);y.push({name:k,index:ge,type:Fe,compression:Q}),M-=k.length+3}const P=ft.channels,b=new Array(o.inputChannels.length);for(let k=0;k<o.inputChannels.length;++k){const G=b[k]={},Q=P[k];G.name=Q.name,G.compression=0,G.decoded=!1,G.type=Q.pixelType,G.pLinear=Q.pLinear,G.width=o.columns,G.height=o.lines}const S={idx:new Array(3)};for(let k=0;k<o.inputChannels.length;++k){const G=b[k];for(let Q=0;Q<y.length;++Q){const ie=y[Q];G.name==ie.name&&(G.compression=ie.compression,ie.index>=0&&(S.idx[ie.index]=k),G.offset=k)}}let E,D,U;if(A.acCompressedSize>0)switch(A.acCompression){case 0:E=new Uint16Array(A.totalAcUncompressedCount),Ct(o.array,f,m,A.acCompressedSize,E,A.totalAcUncompressedCount);break;case 1:const k=o.array.slice(m.value,m.value+A.totalAcUncompressedCount),G=Ut(k);E=new Uint16Array(G.buffer),m.value+=A.totalAcUncompressedCount;break}if(A.dcCompressedSize>0){const k={array:o.array,offset:m,size:A.dcCompressedSize};D=new Uint16Array(hn(k).buffer),m.value+=A.dcCompressedSize}if(A.rleRawSize>0){const k=o.array.slice(m.value,m.value+A.rleCompressedSize),G=Ut(k);U=Fn(G.buffer),m.value+=A.rleCompressedSize}let N=0;const V=new Array(b.length);for(let k=0;k<V.length;++k)V[k]=new Array;for(let k=0;k<o.lines;++k)for(let G=0;G<b.length;++G)V[G].push(N),N+=b[G].width*o.type*2;Ns(S,V,b,E,D,w);for(let k=0;k<b.length;++k){const G=b[k];if(!G.decoded)switch(G.compression){case 2:let Q=0,ie=0;for(let ge=0;ge<o.lines;++ge){let Fe=V[k][Q];for(let fe=0;fe<G.width;++fe){for(let te=0;te<2*G.type;++te)w[Fe++]=U[ie+te*G.width*G.height];ie++}Q++}break;case 1:default:throw new Error("EXRLoader.parse: unsupported channel compression")}}return new DataView(w.buffer)}function qt(o,f){const m=new Uint8Array(o);let w=0;for(;m[f.value+w]!=0;)w+=1;const A=new TextDecoder().decode(m.slice(f.value,f.value+w));return f.value=f.value+w+1,A}function js(o,f,m){const w=new TextDecoder().decode(new Uint8Array(o).slice(f.value,f.value+m));return f.value=f.value+m,w}function Ys(o,f){const m=Be(o,f),w=Ue(o,f);return[m,w]}function Qs(o,f){const m=Ue(o,f),w=Ue(o,f);return[m,w]}function Be(o,f){const m=o.getInt32(f.value,!0);return f.value=f.value+4,m}function Ue(o,f){const m=o.getUint32(f.value,!0);return f.value=f.value+4,m}function Nn(o,f){const m=o[f.value];return f.value=f.value+1,m}function ot(o,f){const m=o.getUint8(f.value);return f.value=f.value+1,m}const De=function(o,f){let m;return"getBigInt64"in DataView.prototype?m=Number(o.getBigInt64(f.value,!0)):m=o.getUint32(f.value+4,!0)+Number(o.getUint32(f.value,!0)<<32),f.value+=8,m};function be(o,f){const m=o.getFloat32(f.value,!0);return f.value+=4,m}function Ws(o,f){return At.toHalfFloat(be(o,f))}function B(o){const f=(o&31744)>>10,m=o&1023;return(o>>15?-1:1)*(f?f===31?m?NaN:1/0:Math.pow(2,f-15)*(1+m/1024):6103515625e-14*(m/1024))}function Lt(o,f){const m=o.getUint16(f.value,!0);return f.value+=2,m}function Ks(o,f){return B(Lt(o,f))}function qs(o,f,m,w){const A=m.value,y=[];for(;m.value<A+w-1;){const M=qt(f,m),P=Be(o,m),b=ot(o,m);m.value+=3;const S=Be(o,m),E=Be(o,m);y.push({name:M,pixelType:P,pLinear:b,xSampling:S,ySampling:E})}return m.value+=1,y}function $s(o,f){const m=be(o,f),w=be(o,f),A=be(o,f),y=be(o,f),M=be(o,f),P=be(o,f),b=be(o,f),S=be(o,f);return{redX:m,redY:w,greenX:A,greenY:y,blueX:M,blueY:P,whiteX:b,whiteY:S}}function Js(o,f){const m=["NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","B44_COMPRESSION","B44A_COMPRESSION","DWAA_COMPRESSION","DWAB_COMPRESSION"],w=ot(o,f);return m[w]}function er(o,f){const m=Be(o,f),w=Be(o,f),A=Be(o,f),y=Be(o,f);return{xMin:m,yMin:w,xMax:A,yMax:y}}function tr(o,f){const m=["INCREASING_Y","DECREASING_Y","RANDOM_Y"],w=ot(o,f);return m[w]}function nr(o,f){const m=["ENVMAP_LATLONG","ENVMAP_CUBE"],w=ot(o,f);return m[w]}function sr(o,f){const m=["ONE_LEVEL","MIPMAP_LEVELS","RIPMAP_LEVELS"],w=["ROUND_DOWN","ROUND_UP"],A=Ue(o,f),y=Ue(o,f),M=ot(o,f);return{xSize:A,ySize:y,levelMode:m[M&15],roundingMode:w[M>>4]}}function rr(o,f){const m=be(o,f),w=be(o,f);return[m,w]}function ir(o,f){const m=be(o,f),w=be(o,f),A=be(o,f);return[m,w,A]}function or(o,f,m,w,A){if(w==="string"||w==="stringvector"||w==="iccProfile")return js(f,m,A);if(w==="chlist")return qs(o,f,m,A);if(w==="chromaticities")return $s(o,m);if(w==="compression")return Js(o,m);if(w==="box2i")return er(o,m);if(w==="envmap")return nr(o,m);if(w==="tiledesc")return sr(o,m);if(w==="lineOrder")return tr(o,m);if(w==="float")return be(o,m);if(w==="v2f")return rr(o,m);if(w==="v3f")return ir(o,m);if(w==="int")return Be(o,m);if(w==="rational")return Ys(o,m);if(w==="timecode")return Qs(o,m);if(w==="preview")return m.value+=A,"skipped";m.value+=A}function ar(o,f){const m=Math.log2(o);return f=="ROUND_DOWN"?Math.floor(m):Math.ceil(m)}function lr(o,f,m){let w=0;switch(o.levelMode){case"ONE_LEVEL":w=1;break;case"MIPMAP_LEVELS":w=ar(Math.max(f,m),o.roundingMode)+1;break;case"RIPMAP_LEVELS":throw new Error("THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.")}return w}function kn(o,f,m,w){const A=new Array(o);for(let y=0;y<o;y++){const M=1<<y;let P=f/M|0;w=="ROUND_UP"&&P*M<f&&(P+=1);const b=Math.max(P,1);A[y]=(b+m-1)/m|0}return A}function cr(){const o=this,f=o.offset,m={value:0};for(let w=0;w<o.tileCount;w++){const A=Be(o.viewer,f),y=Be(o.viewer,f);f.value+=8,o.size=Ue(o.viewer,f);const M=A*o.blockWidth,P=y*o.blockHeight;o.columns=M+o.blockWidth>o.width?o.width-M:o.blockWidth,o.lines=P+o.blockHeight>o.height?o.height-P:o.blockHeight;const b=o.columns*o.totalBytes,E=o.size<o.lines*b?o.uncompress(o):un(o);f.value+=o.size;for(let D=0;D<o.lines;D++){const U=D*o.columns*o.totalBytes;for(let N=0;N<o.inputChannels.length;N++){const V=ft.channels[N].name,k=o.channelByteOffsets[V]*o.columns,G=o.decodeChannels[V];if(G===void 0)continue;m.value=U+k;const Q=(o.height-(1+P+D))*o.outLineWidth;for(let ie=0;ie<o.columns;ie++){const ge=Q+(ie+M)*o.outputChannels+G;o.byteArray[ge]=o.getter(E,m)}}}}}function ur(){const o=this,f=o.offset,m={value:0};for(let w=0;w<o.height/o.blockHeight;w++){const A=Be(o.viewer,f)-ft.dataWindow.yMin;o.size=Ue(o.viewer,f),o.lines=A+o.blockHeight>o.height?o.height-A:o.blockHeight;const y=o.columns*o.totalBytes,P=o.size<o.lines*y?o.uncompress(o):un(o);f.value+=o.size;for(let b=0;b<o.blockHeight;b++){const S=w*o.blockHeight,E=b+o.scanOrder(S);if(E>=o.height)continue;const D=b*y,U=(o.height-1-E)*o.outLineWidth;for(let N=0;N<o.inputChannels.length;N++){const V=ft.channels[N].name,k=o.channelByteOffsets[V]*o.columns,G=o.decodeChannels[V];if(G!==void 0){m.value=D+k;for(let Q=0;Q<o.columns;Q++){const ie=U+Q*o.outputChannels+G;o.byteArray[ie]=o.getter(P,m)}}}}}}function hr(o,f,m){const w={};if(o.getUint32(0,!0)!=20000630)throw new Error("THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format.");w.version=o.getUint8(4);const A=o.getUint8(5);w.spec={singleTile:!!(A&2),longName:!!(A&4),deepFormat:!!(A&8),multiPart:!!(A&16)},m.value=8;let y=!0;for(;y;){const M=qt(f,m);if(M==0)y=!1;else{const P=qt(f,m),b=Ue(o,m),S=or(o,f,m,P,b);S===void 0?console.warn(`THREE.EXRLoader: Skipped unknown header attribute type '${P}'.`):w[M]=S}}if(A&-7)throw console.error("THREE.EXRHeader:",w),new Error("THREE.EXRLoader: Provided file is currently unsupported.");return w}function pr(o,f,m,w,A){const y={size:0,viewer:f,array:m,offset:w,width:o.dataWindow.xMax-o.dataWindow.xMin+1,height:o.dataWindow.yMax-o.dataWindow.yMin+1,inputChannels:o.channels,channelByteOffsets:{},scanOrder:null,totalBytes:null,columns:null,lines:null,type:null,uncompress:null,getter:null,format:null,colorSpace:je};switch(o.compression){case"NO_COMPRESSION":y.blockHeight=1,y.uncompress=un;break;case"RLE_COMPRESSION":y.blockHeight=1,y.uncompress=Xs;break;case"ZIPS_COMPRESSION":y.blockHeight=1,y.uncompress=hn;break;case"ZIP_COMPRESSION":y.blockHeight=16,y.uncompress=hn;break;case"PIZ_COMPRESSION":y.blockHeight=32,y.uncompress=Vs;break;case"PXR24_COMPRESSION":y.blockHeight=16,y.uncompress=Zs;break;case"DWAA_COMPRESSION":y.blockHeight=32,y.uncompress=On;break;case"DWAB_COMPRESSION":y.blockHeight=256,y.uncompress=On;break;default:throw new Error("EXRLoader.parse: "+o.compression+" is unsupported")}const M={};for(const E of o.channels)switch(E.name){case"Y":case"R":case"G":case"B":case"A":M[E.name]=!0,y.type=E.pixelType}let P=!1;if(M.R&&M.G&&M.B)P=!M.A,y.outputChannels=4,y.decodeChannels={R:0,G:1,B:2,A:3};else if(M.Y)y.outputChannels=1,y.decodeChannels={Y:0};else throw new Error("EXRLoader.parse: file contains unsupported data channels.");if(y.type==1)switch(A){case bt:y.getter=Ks;break;case Le:y.getter=Lt;break}else if(y.type==2)switch(A){case bt:y.getter=be;break;case Le:y.getter=Ws}else throw new Error("EXRLoader.parse: unsupported pixelType "+y.type+" for "+o.compression+".");y.columns=y.width;const b=y.width*y.height*y.outputChannels;switch(A){case bt:y.byteArray=new Float32Array(b),P&&y.byteArray.fill(1,0,b);break;case Le:y.byteArray=new Uint16Array(b),P&&y.byteArray.fill(15360,0,b);break;default:console.error("THREE.EXRLoader: unsupported type: ",A);break}let S=0;for(const E of o.channels)y.decodeChannels[E.name]!==void 0&&(y.channelByteOffsets[E.name]=S),S+=E.pixelType*2;if(y.totalBytes=S,y.outLineWidth=y.width*y.outputChannels,o.lineOrder==="INCREASING_Y"?y.scanOrder=E=>E:y.scanOrder=E=>y.height-1-E,y.outputChannels==4?(y.format=Xr,y.colorSpace=je):(y.format=Vr,y.colorSpace=Zr),o.spec.singleTile){y.blockHeight=o.tiles.ySize,y.blockWidth=o.tiles.xSize;const E=lr(o.tiles,y.width,y.height),D=kn(E,y.width,o.tiles.xSize,o.tiles.roundingMode),U=kn(E,y.height,o.tiles.ySize,o.tiles.roundingMode);y.tileCount=D[0]*U[0];for(let N=0;N<E;N++)for(let V=0;V<U[N];V++)for(let k=0;k<D[N];k++)De(f,w);y.decode=cr.bind(y)}else{y.blockWidth=y.width;const E=Math.ceil(y.height/y.blockHeight);for(let D=0;D<E;D++)De(f,w);y.decode=ur.bind(y)}return y}const Bn={value:0},Un=new DataView(e),fr=new Uint8Array(e),ft=hr(Un,e,Bn),yt=pr(ft,Un,fr,Bn,this.type);return yt.decode(),{header:ft,width:yt.width,height:yt.height,data:yt.byteArray,format:yt.format,colorSpace:yt.colorSpace,type:this.type}}setDataType(e){return this.type=e,this}load(e,t,s,n){function r(i,a){i.colorSpace=a.colorSpace,i.minFilter=It,i.magFilter=It,i.generateMipmaps=!1,i.flipY=!1,t&&t(i,a)}return super.load(e,r,s,n)}}function zo(c,e=10,t="red"){const s=new Ee(e,e,e),n=new Ve({color:t}),r=new F(s,n);return r.position.set(...c),r}function Xo(c){const e=new jr().load(["http://guangfu//scene/LF.jpg","http://guangfu//scene/RT.jpg","http://guangfu//scene/UP.jpg","http://guangfu//scene/DN.jpg","http://guangfu//scene/FR.jpg","http://guangfu//scene/BK.jpg"]);return c.background=e,e}function Vo(c){let e=[];return c.traverse(s=>{s.layers.enable(3),s.isMesh&&(Array.isArray(s.material)?s.material.forEach(n=>e.push(n)):e.push(s.material))}),[...new Set(e)]}const Zo=c=>{const e=new _t().load(c),t=new Yr(4e3,4e3),s=new zt({color:16777215,map:e,side:rt}),n=new F(t,s);return n.rotation.x=-Math.PI/2,n.material.map.repeat.set(64,64),n.position.y=-8,n.material.map.wrapS=Ce,n.material.map.wrapT=Ce,n};function jo(c,e){const t=new ri(c,e.domElement);return t.enableDamping=!0,t.dampingFactor=.1,t.minZoom=1e3,t.maxDistance=5e4,t.maxPolarAngle=Math.PI/2,t}const Yo=()=>{const c=new Qr;return c.onStart=function(e,t,s){},c.onLoad=function(){},c.onProgress=function(e,t,s){},c.onError=function(e){},c},Qo=(c="model/西宿舍楼/xisushelou02.FBX",e,t)=>{const s=new _i(t);return s.load(c,n=>{n.traverse(r=>{if(r.castShadow=!0,r.receiveShadow=!0,r.material){let i=function(a){a.side=rt,a.vertexColors=!1};Array.isArray(r.material)?r.material.map(a=>i(a)):i(r.material)}}),e(n)},n=>{}),s},Wo=(c="",e=()=>{})=>{new Gi().load(c,s=>e(s.scene),s=>{},s=>{})};function Ko(c,e,t,s,n=[]){const r=new ii(t);r.setSize(s.offsetWidth,s.offsetHeight),r.setPixelRatio(window.devicePixelRatio*2);const i=new Eo(c,e);r.addPass(i);const a=new zn(So);r.addPass(a);const l=new zn(Mo),h=t.getPixelRatio();l.material.uniforms.resolution.value.x=1/(s.offsetWidth*h),l.material.uniforms.resolution.value.y=1/(s.offsetHeight*h);const p=new ut(new Me(s.offsetWidth,s.offsetHeight),c,e,n);return p.renderToScreen=!0,p.edgeStrength=4,p.edgeGlow=0,p.edgeThickness=8,p.pulsePeriod=0,p.usePatternTexture=!1,p.visibleEdgeColor.set("red"),p.hiddenEdgeColor.set("red"),r.addPass(p),{Composer:r,outlinePass:p}}function qo(){let c=new Zt;return c.setMode(0),c.domElement.style.position="absolute",c.domElement.style.left="0px",c.domElement.style.top="0px",document.body.appendChild(c.domElement),c}function $o(c){return new Me(c.offsetX/c.target.clientWidth*2-1,-(c.offsetY/c.target.clientHeight)*2+1)}function Jo(c,e,t,s=!1){const n=new ys;n.setFromCamera(c,e);const r=n.intersectObjects(t.children);return s?r:r.length>0?r[0]:null}const No=c=>c.reduce((e,t)=>[...e,t.x,t.y,t.z],[]);function ko(c){const e=new Ze,t=new Float32Array(c);e.setAttribute("position",new pt(t,3));const s=new Yt({color:"red"});return new ze(e,s)}function ea(c,e="red"){let t=new Ze;t.setFromPoints(c);let s=new Yt({color:e});return new ze(t,s)}function ss(c,e="indexFace",t=null){if(e==="pointFace")return{faceGroup:c.map((n,r,i)=>r>=2?[i[0],i[r-1],i[r]]:!1).filter(n=>n).reduce((n,r)=>[...n,...r],[]).reduce((n,r)=>[...n,r.x,r.y,r.z],[])};{const s=c.map((T,x,v)=>x>=2?[0,x-1,x]:!1).filter(T=>T).reduce((T,x)=>[...T,...x],[]),n=c.reduce((T,x)=>[...T,x.x,x.y,x.z],[]),r=c.reduce((T,x)=>({x:[...T.x,x.x],y:[...T.y,x.y],z:[...T.z,x.z]}),{x:[],y:[],z:[]});let i=new L(Math.max(...r.x),Math.max(...r.y),Math.max(...r.z)),a=new L(Math.min(...r.x),Math.min(...r.y),Math.min(...r.z)),l=new L(i.x,i.y,a.z),h=new L(a.x,a.y,i.z),p=i.x-a.x,u=i.z-a.z;const d=p>u?p:u;if(t){const T=new Ee(10,10,10),x=new Ve({color:16777215*Math.random()}),v=new F(T,x),R=v.clone(),_=v.clone(),I=v.clone();R.position.set(i.x,i.y,i.z),v.position.set(a.x,a.y,a.z),_.position.set(l.x,l.y,l.z),I.position.set(h.x,h.y,h.z),t.add(R),t.add(v),t.add(_),t.add(I)}const g=c.map((T,x,v)=>{let R=new Me((T.x-a.x)/d,(T.z-a.z)/d),_=new Me((T.x-l.x)/d,(T.z-l.z)/d),I=new Me((T.x-h.x)/d,(T.z-h.z)/d);return R||_||I}).reduce((T,x)=>[...T,...x],[]);return{indexGroup:s,faceGroup:n,uvGroup:g}}}function Bo(c,e,t,s="https://img0.baidu.com/it/u=981218435,2998857702&fm=253&app=120&size=w931&n=0&f=JPEG&fmt=auto?sec=1677603600&t=455d091ed3eb38bf61a72df4b1285a9d"){const n=new Ze,r=new Float32Array(c);if(n.setAttribute("position",new pt(r,3)),e){let p=new Uint16Array(e);n.index=new pt(p,1)}t&&(n.attributes.uv=new Oe(t,2));const a=new _t().load(s);a.wrapS=Ce,a.wrapT=Ce,a.repeat.set(1,1);const l=new Ve({side:rt,map:a,transparent:!0,opacity:.8});return new F(n,l)}function Uo(c,e="red",t=10){const s=new Ze;s.setAttribute("position",new Oe(c,3));const n=new fs({color:new we(e),size:t});return new ms(s,n)}function xt(c,e,t){const s=c.map((l,h,p)=>h>=2?[p[0],p[h-1],p[h]]:!1).filter(l=>l).reduce((l,h)=>[...l,...h],[]).reduce((l,h)=>[h.x,h.y,h.z,...l],[]),n=new Ze,r=new Float32Array(s);n.setAttribute("position",new pt(r,3));const i=new Ve({side:rt,color:t,transparent:!0,opacity:.6}),a=new F(n,i);return a.name=e,a}function ta(c,e,t){const s=No(e);if(c.points?c.points.geometry.setFromPoints(e)||c.points.geometry.setAttribute("position",new Oe(s,3)):(c.points=Uo(s,16777215*Math.random()),t.add(c.points)),c.line?c.line.geometry.setFromPoints(e):(c.line=ko(s),t.add(c.line)),c.area){const{indexGroup:n,faceGroup:r,uvGroup:i}=ss(e,"indexFace");c.area.geometry.setIndex(n),c.area.geometry.setAttribute("position",new Oe(r,3)),c.area.geometry.setAttribute("uv",new Oe(i,2))}else{const{indexGroup:n,faceGroup:r,uvGroup:i}=ss(e,"indexFace");c.area=Bo(r,n,i),c.area.position.y+=10,t.add(c.area)}}function na(c,e=null){const t=new L;c.getWorldPosition(t);let{max:s,min:n}=new ws().setFromObject(c),r=new L(s.x,s.y,s.z),i=new L(n.x,s.y,s.z),a=new L(s.x,s.y,n.z),l=new L(s.x,n.y,s.z),h=new L(n.x,n.y,n.z),p=new L(n.x,s.y,n.z),u=new L(n.x,n.y,s.z),d=new L(s.x,n.y,n.z),g=[r,i,a,l,h,p,u,d];const T=xt([g[0],g[1],g[5],g[2]],"top_plane","red"),x=xt([g[3],g[6],g[4],g[7]],"bottom_plane","yellow"),v=xt([g[1],g[6],g[4],g[5]],"left_plane","blue"),R=xt([g[0],g[3],g[7],g[2]],"right_plane","green"),_=xt([g[1],g[0],g[3],g[6]],"front_plane","DarkSlateGray"),I=xt([g[5],g[2],g[7],g[4]],"back_plane","Indigo"),O=[T,x,v,R,_,I],H=[];H[0]=new Tt(new L(0,-1,0),s.y),H[1]=new Tt(new L(0,1,0),-n.y),H[2]=new Tt(new L(1,0,0),-n.x),H[3]=new Tt(new L(-1,0,0),s.x),H[4]=new Tt(new L(0,0,-1),s.z),H[5]=new Tt(new L(0,0,1),-n.z);const j={x:{clip:H[2],width:s.x-n.x,end:H[2].constant},_x:{clip:H[3],width:s.x-n.x,end:H[3].constant},y:{clip:H[1],width:s.y-n.y,end:H[1].constant},_y:{clip:H[0],width:s.y-n.y,end:H[0].constant},z:{clip:H[4],width:s.z-n.z,end:H[4].constant},_z:{clip:H[5],width:s.z-n.z,end:H[5].constant},reset:()=>{["x","y","z"].forEach(C=>{j[C].clip.constant=j[C].end,j["_"+C].clip.constant=j["_"+C].end})}},W=C=>(j.reset(),j[C].clip.constant-=j[C].width,(z,X)=>{j[C].clip.constant+z>j[C].end?X():j[C].clip.constant+=z});return Array.isArray(c.material)?c.material=c.material.map(C=>C.clone()):c.material=c.material.clone(),c.material.clippingPlanes=H,e&&(O.forEach(C=>e.add(C)),g.map(C=>{const z=new Ee(10,10,10),X=new Ve({color:"red"}),Y=new F(z,X);Y.position.set(...C),e.add(Y)}),H.forEach(C=>e.add(new Wr(C,300,16776960)))),{max:s,min:n,plane_arr:O,ponit_arr:g,clipFace_arr:H,clipFace_Way:j,pipeAnimation:W,position:t}}const sa=c=>new Kr(c.map(e=>new L(...e)),!1),ra=(c,e,t=1e-4,s="go",n=()=>{},r=()=>{})=>{let i=s==="go"?1e-4:1;return s==="go"?()=>{i+=t,i>1&&(i=1);const a=c.getPointAt(i);if(n(e,a,i),e.position.set(a.x,a.y,a.z),i===1)return r()}:()=>{i-=t,i<0&&(i=0);const a=c.getPoint(i);if(n(e,a,i),e.position.copy(a),i===0)return r()}};function ia(c,e){const t=new vs(e),s=new Fo().load(c,n=>{const r=t.fromEquirectangular(n).texture;return t.dispose(),r});return s.mipping=Ln,s}function oa(c,e){const t=new vs(e);return new Oo().load(c,n=>{n.mapping=Ln;const r=t.fromEquirectangular(n).texture;return t.dispose(),r})}function aa(c,e,t=1,s=10,n=640,r=80,i=!1){const a=new qr(c,n,s,r,i),h=new _t().load(e);h.wrapS=Ce,h.wrapT=Ce,h.repeat.x=10,h.repeat.y=4,h.offset.y=.9;const p=new zt({map:h,transparent:!0,side:rt,opacity:t});return new F(a,p)}function la(c){const t=new _t().load(c);return t.wrapS=Ce,t.wrapT=Ce,t.repeat.x=10,t.repeat.y=4,t.offset.y=.9,t}async function ca(c){var e=new Mt;const t=new Image;return t.crossOrigin="anonymous",t.src=c,await new Promise((s,n)=>{t.onload=()=>{e.image=t,s(!0)}}),e.wrapS=Ce,e.wrapT=Ce,e.repeat.x=10,e.repeat.y=4,e.offset.y=.9,e.needsUpdate=!0,e}async function ua(c){const e=document.createElement("video");e.crossOrigin="anonymous",e.src=c,e.loop=!0,await new Promise((s,n)=>{e.onloadeddata=()=>{s(!0)}});const t=new $r(e);return t.video=e,t}function ha(c=144){const e=new xs,t=1/c;let s=0;return n=>{const r=e.getDelta();s=s+r,s>t&&(n(),s=0)}}function pa(c){const e=new xs,t=new Jr(c);let s=c.animations;return{mixer:t,actions:s,runAction:(i,a=1,l=0)=>{const h=t.clipAction(i);return h.loop=ti,h.time=l,h.timeScale=a,h.clampWhenFinished=!0,h},mixerRender:()=>{const i=e.getDelta();t.update(i)}}}function fa(c,e="deg"){let t=new ei,s=new ve().setFromUnitVectors(c.object.up,new L(0,1,0)),n=c.object.position,r=new L().copy(n).sub(c.target);t.setFromVector3(r),{vertical:()=>t.phi=.001,horizontal:()=>t.phi=Math.PI/2,deg:()=>t.theta+=Math.PI/4}[e](),r.setFromSpherical(t),r.applyQuaternion(s),n.copy(c.target).add(r),c.target.y=0,c.update()}function da(c,e,t,s){const n=new bo(e,c.domElement);return n.addEventListener("change",s),n.addEventListener("dragging-changed",function(r){t.enabled=!r.value}),window.addEventListener("keydown",function(r){switch(console.log(r.keyCode),r.keyCode){case 16:n.setTranslationSnap(100),n.setRotationSnap(Se.degToRad(15)),n.setScaleSnap(.25);break;case 87:n.setMode("translate");break;case 69:n.setMode("rotate");break;case 82:n.setMode("scale");break;case 107:n.setSize(n.size+.1);break;case 189:case 109:n.setSize(Math.max(n.size-.1,.1));break;case 32:n.enabled=!n.enabled;break;case 27:n.reset();break}}),window.addEventListener("keyup",function(r){switch(r.keyCode){case 16:n.setTranslationSnap(null),n.setRotationSnap(null),n.setScaleSnap(null);break}}),n}const ma=(c=100,e=100,t=300,s=.1)=>{const n=new Float32Array(c*3),r=new Float32Array(c*3);function i(){let p,u,d;do p=Math.random()*2*t-t,u=Math.random()*2*t-t,d=Math.random()*2*t-t;while(Math.abs(p)<=e&&Math.abs(u)<=e&&Math.abs(d)<=e);return[p,u,d]}function a(){const p=(Math.random()-.5)*s,u=(Math.random()-.5)*s,d=(Math.random()-.5)*s;return[p,u,d]}for(let p=0;p<c;p++)n.set(i(),p*3),r.set(a(),p*3);const l=new Ze;l.setAttribute("position",new pt(n,3));function h(){for(let p=0;p<c;p++){n[p*3]+=r[p*3],n[p*3+1]+=r[p*3+1],n[p*3+2]+=r[p*3+2];const[u,d,g]=a();if(r[p*3]+=u,r[p*3+1]+=d,r[p*3+2]+=g,Math.abs(n[p*3])>t||Math.abs(n[p*3+1])>t||Math.abs(n[p*3+2])>t||Math.abs(n[p*3])<e&&Math.abs(n[p*3+1])<e&&Math.abs(n[p*3+2])<e){const[T,x,v]=i();n[p*3]=T,n[p*3+1]=x,n[p*3+2]=v}}l.attributes.position.needsUpdate=!0}return{geometry:l,geometryRender:h}};export{ia as A,oa as B,Gi as G,Eo as R,qo as a,ha as b,la as c,Vo as d,ca as e,Jo as f,$o as g,ua as h,ma as i,Xo as j,Zo as k,Qo as l,Ko as m,ta as n,Yo as o,Wo as p,aa as q,na as r,jo as s,da as t,ra as u,sa as v,ea as w,pa as x,fa as y,zo as z};
